"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction useSupabaseData() {\n    // Caches for songs and liked songs to avoid repeated cloud fetches\n    const songsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const likedSongsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Personalized songs state (smart sorted, filtered, and history-excluded)\n    const [personalizedSongs, setPersonalizedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Trending songs state (top 15 by views+likes)\n    const [trendingSongs, setTrendingSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [recentlyPlayedSongs, setRecentlyPlayedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Get user ID from localStorage\n    const getUserId = ()=>{\n        return localStorage.getItem(\"user_id\");\n    };\n    // Get personalized songs based on user's actual listening preferences\n    const getSmartPersonalizedSongs = async (userId, listenedSongsInBatch, excludeSongs)=>{\n        try {\n            var _listenedSongsInBatch_;\n            console.log(\"\\uD83E\\uDDE0 Fetching smart personalized songs based on listening behavior\");\n            console.log(\"\\uD83C\\uDFB5 Songs user actually listened to:\", listenedSongsInBatch.map((s)=>s.name));\n            if (listenedSongsInBatch.length === 0) {\n                console.log(\"⚠️ No listened songs in batch, falling back to regular personalization\");\n                return [];\n            }\n            // Extract tags and artists from listened songs\n            const preferredTags = new Set();\n            const preferredArtists = new Set();\n            listenedSongsInBatch.forEach((song)=>{\n                var _song_tags;\n                (_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.forEach((tag)=>preferredTags.add(tag.toLowerCase()));\n                preferredArtists.add(song.artist.toLowerCase());\n            });\n            console.log(\"\\uD83C\\uDFF7️ Preferred tags:\", Array.from(preferredTags));\n            console.log(\"\\uD83C\\uDFA4 Preferred artists:\", Array.from(preferredArtists));\n            // Use cache if available, otherwise fetch and cache\n            let songsData = songsCache.current;\n            if (!songsData) {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for smart personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n            }\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n            }\n            // Filter and score songs based on listening preferences and language\n            // Use the language of the first listened song as the filter\n            const languageFilter = (_listenedSongsInBatch_ = listenedSongsInBatch[0]) === null || _listenedSongsInBatch_ === void 0 ? void 0 : _listenedSongsInBatch_.language;\n            const availableSongs = songsData.filter((song)=>{\n                return !excludeSongs.has(song.file_id.toString()) && song.language === languageFilter;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs for smart recommendations (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // Score songs based on user's listening preferences\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // High priority: Tag matching with listened songs\n                const songTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.map((tag)=>tag.toLowerCase())) || [];\n                const matchingTags = songTags.filter((tag)=>preferredTags.has(tag));\n                score += matchingTags.length * 25; // Higher weight for tag matching\n                // High priority: Artist matching with listened songs\n                if (preferredArtists.has(song.artist.toLowerCase())) {\n                    score += 30; // Higher weight for artist matching\n                }\n                // Medium priority: Same language as listened songs\n                const listenedLanguages = listenedSongsInBatch.map((s)=>s.language);\n                if (listenedLanguages.includes(song.language)) {\n                    score += 15;\n                }\n                // Lower priority: General popularity\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Bonus for liked songs\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 10;\n                }\n                // Add small randomness to avoid repetition\n                score += Math.random() * 2;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 15) // Get more songs for variety\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83E\\uDDE0 Smart recommendations based on listening behavior:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getSmartPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n            return;\n        }\n        try {\n            console.log(\"Fetching all songs from supabase...\");\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            console.log(\"Fetched songs:\", songsData === null || songsData === void 0 ? void 0 : songsData.length);\n            // Fetch liked songs\n            let userLikedSongs = new Set();\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n            }\n            // Fetch user history (for minutes_listened)\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened, songs(*)\").eq(\"user_id\", userId).order(\"minutes_listened\", {\n                ascending: false\n            });\n            if (historyError) throw historyError;\n            console.log(\"Fetched user history:\", historyData === null || historyData === void 0 ? void 0 : historyData.length);\n            // Get top 15 most listened songs from history\n            const topHistory = (historyData || []).slice(0, 15).filter((h)=>h.songs);\n            // Collect tags and artists from top 15\n            const tagCount = {};\n            const artistCount = {};\n            topHistory.forEach((h)=>{\n                // h.songs may be an array or object, use first if array\n                const songObj = Array.isArray(h.songs) ? h.songs[0] : h.songs;\n                ((songObj === null || songObj === void 0 ? void 0 : songObj.tags) || []).forEach((tag)=>{\n                    const t = tag.toLowerCase();\n                    tagCount[t] = (tagCount[t] || 0) + 1;\n                });\n                if (songObj === null || songObj === void 0 ? void 0 : songObj.artist) {\n                    const a = songObj.artist.toLowerCase();\n                    artistCount[a] = (artistCount[a] || 0) + 1;\n                }\n            });\n            // Find most common tags and artists\n            const commonTags = Object.entries(tagCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [tag] = param;\n                return tag;\n            });\n            const commonArtists = Object.entries(artistCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [artist] = param;\n                return artist;\n            });\n            console.log(\"Found similar tags:\", commonTags);\n            console.log(\"Found similar artists:\", commonArtists);\n            // Songs in history (to exclude for smart sort)\n            const historySongIds = new Set((historyData || []).map((h)=>{\n                var _h_song_id;\n                return (_h_song_id = h.song_id) === null || _h_song_id === void 0 ? void 0 : _h_song_id.toString();\n            }));\n            // Convert all songs\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            setSongs(convertedSongs); // songs is now all songs, not personalized\n            // Filter out songs in history for personalized sort\n            const filteredSongs = convertedSongs.filter((song)=>!historySongIds.has(song.id));\n            // Score songs by tag/artist match\n            const scoredSongs = filteredSongs.map((song)=>{\n                let score = 0;\n                // Tag match\n                const songTags = (song.tags || []).map((t)=>t.toLowerCase());\n                score += songTags.filter((t)=>commonTags.includes(t)).length * 10;\n                // Artist match\n                if (song.artist && commonArtists.includes(song.artist.toLowerCase())) {\n                    score += 20;\n                }\n                // Popularity\n                score += (song.views || 0) + (song.likes || 0);\n                return {\n                    song,\n                    score\n                };\n            });\n            // Sort by score descending\n            const personalizedSorted = scoredSongs.sort((a, b)=>b.score - a.score).map((s)=>s.song);\n            setPersonalizedSongs(personalizedSorted);\n            // Trending: top 15 by views+likes (from all songs, including history)\n            const trending = [\n                ...convertedSongs\n            ].sort((a, b)=>b.views + b.likes - (a.views + a.likes)).slice(0, 15);\n            setTrendingSongs(trending);\n            console.log(\"Trending songs:\", trending.map((s)=>\"\".concat(s.name, \" (\").concat(s.views, \" views, \").concat(s.likes, \" likes)\")));\n            // Set last played song as before\n            const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", userId).single();\n            if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n            setSongs([]);\n        }\n    };\n    // Get personalized songs with proper error handling and filtering\n    const getPersonalizedSongs = async (userId, currentSong, listenedSongs)=>{\n        try {\n            console.log(\"\\uD83C\\uDFB5 Fetching personalized songs for:\", currentSong.name);\n            console.log(\"\\uD83C\\uDFB5 Listened songs count:\", (listenedSongs === null || listenedSongs === void 0 ? void 0 : listenedSongs.size) || 0);\n            // 1. Fetch all songs from cache or cloud\n            let songsData = songsCache.current;\n            if (!songsData) {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n            }\n            // 2. Fetch user's listening history (not cached, as it may change frequently)\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened\").eq(\"user_id\", userId);\n            if (historyError) {\n                console.error(\"❌ Error fetching history:\", historyError);\n            }\n            const historyMap = new Map();\n            if (historyData) {\n                historyData.forEach((h)=>historyMap.set(h.song_id, h.minutes_listened || 0));\n            }\n            // 3. Get user's liked songs from cache or cloud\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n            }\n            // 4. Filter and score songs (add language filter)\n            const languageFilter = currentSong.language;\n            const availableSongs = songsData.filter((song)=>{\n                // Exclude current song\n                if (song.file_id === currentSong.file_id) {\n                    return false;\n                }\n                // Exclude listened songs if provided\n                if (listenedSongs && listenedSongs.has(song.file_id.toString())) {\n                    console.log(\"\\uD83D\\uDEAB Excluding listened song: \".concat(song.name, \" by \").concat(song.artist));\n                    return false;\n                }\n                // Only include songs with the same language as current song\n                if (song.language !== languageFilter) {\n                    return false;\n                }\n                return true;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs after filtering (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // 5. Score and sort songs\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // Tag matching (highest priority)\n                const matchingTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.filter((tag)=>{\n                    var _currentSong_tags;\n                    return (_currentSong_tags = currentSong.tags) === null || _currentSong_tags === void 0 ? void 0 : _currentSong_tags.includes(tag);\n                })) || [];\n                score += matchingTags.length * 15;\n                // Artist matching\n                if (song.artist === currentSong.artist) {\n                    score += 25;\n                }\n                // Language matching\n                if (song.language === currentSong.language) {\n                    score += 10;\n                }\n                // Listening history boost\n                const listenedMinutes = historyMap.get(song.file_id) || 0;\n                score += Math.min(listenedMinutes * 2, 20); // Cap at 20 points\n                // Popularity boost (likes and views)\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Liked songs boost\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 8;\n                }\n                // Add controlled randomness to avoid repetition\n                score += Math.random() * 3;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // 6. Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 10) // Get more songs to have a buffer\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83C\\uDFB5 Personalized recommendations:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            console.log(\"\\uD83C\\uDFB5 Total available songs:\", availableSongs.length);\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Fetch recently played songs based on listening history\n    const fetchRecentlyPlayed = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            setRecentlyPlayedSongs([]);\n            return;\n        }\n        try {\n            // Get user's listening history sorted by minutes listened\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"\\n          song_id,\\n          minutes_listened,\\n          songs (*)\\n        \").eq(\"user_id\", userId).order(\"minutes_listened\", {\n                ascending: false\n            }).limit(9);\n            if (historyError) {\n                console.error(\"Error fetching recently played:\", historyError);\n                return;\n            }\n            if (!historyData || historyData.length === 0) {\n                setRecentlyPlayedSongs([]);\n                return;\n            }\n            // Get user's liked songs for proper conversion\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            const userLikedSongs = new Set();\n            if (likedData) {\n                likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n            }\n            // Convert to Song format\n            const recentSongs = historyData.filter((item)=>item.songs) // Ensure song data exists\n            .map((item)=>{\n                const songObj = Array.isArray(item.songs) ? item.songs[0] : item.songs;\n                return convertDatabaseSong(songObj, userLikedSongs.has(item.song_id));\n            });\n            setRecentlyPlayedSongs(recentSongs);\n        } catch (error) {\n            console.error(\"Error fetching recently played songs:\", error);\n            setRecentlyPlayedSongs([]);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", userId);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", userId).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").insert({\n                    user_id: userId,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").insert({\n                user_id: userId,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", userId);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", userId);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", userId);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: userId,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history:\", error);\n                    } else {\n                        console.log(\"✅ History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n        } catch (error) {\n            console.error(\"Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        const userId = getUserId();\n        if (currentSongRef.current && currentSongStartTime && userId) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: userId,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    // Initialize data when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const userId = getUserId();\n        if (userId) {\n            setLoading(true);\n            const loadData = async ()=>{\n                try {\n                    await Promise.all([\n                        fetchSongs(),\n                        fetchPlaylists(),\n                        fetchRecentlyPlayed()\n                    ]);\n                } catch (error) {\n                    console.error(\"Error loading data:\", error);\n                } finally{\n                    setLoading(false);\n                }\n            };\n            loadData();\n        } else {\n            // Reset data when no user\n            songsCache.current = null;\n            likedSongsCache.current = null;\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n            setPlaylists([]);\n            setLikedSongs(new Set());\n            setRecentlyPlayedSongs([]);\n            setLastPlayedSong(null);\n            setLoading(false);\n        }\n    }, [\n        getUserId()\n    ]) // Add dependency to re-run when user changes\n    ;\n    // Also listen for storage changes (when user logs in/out in another tab)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleStorageChange = (e)=>{\n            if (e.key === \"user_id\") {\n                const userId = e.newValue;\n                if (userId) {\n                    setLoading(true);\n                    Promise.all([\n                        fetchSongs(),\n                        fetchPlaylists(),\n                        fetchRecentlyPlayed()\n                    ]).finally(()=>setLoading(false));\n                } else {\n                    // User logged out\n                    songsCache.current = null;\n                    likedSongsCache.current = null;\n                    setSongs([]);\n                    setPersonalizedSongs([]);\n                    setTrendingSongs([]);\n                    setPlaylists([]);\n                    setLikedSongs(new Set());\n                    setRecentlyPlayedSongs([]);\n                    setLastPlayedSong(null);\n                    setLoading(false);\n                }\n            }\n        };\n        window.addEventListener(\"storage\", handleStorageChange);\n        return ()=>window.removeEventListener(\"storage\", handleStorageChange);\n    }, []);\n    return {\n        songs,\n        personalizedSongs,\n        trendingSongs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        recentlyPlayedSongs,\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            const userId = getUserId();\n            if (userId) {\n                setLoading(true);\n                Promise.all([\n                    fetchSongs(),\n                    fetchPlaylists(),\n                    fetchRecentlyPlayed()\n                ]).finally(()=>setLoading(false));\n            }\n        },\n        getPersonalizedSongs,\n        getSmartPersonalizedSongs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBRUo7QUFFN0MsU0FBU0k7SUFDZCxtRUFBbUU7SUFDbkUsTUFBTUMsYUFBYUgsNkNBQU1BLENBQWU7SUFDeEMsTUFBTUksa0JBQWtCSiw2Q0FBTUEsQ0FBcUI7SUFDbkQsTUFBTSxDQUFDSyxPQUFPQyxTQUFTLEdBQUdMLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsMEVBQTBFO0lBQzFFLE1BQU0sQ0FBQ00sbUJBQW1CQyxxQkFBcUIsR0FBR1AsK0NBQVFBLENBQVMsRUFBRTtJQUNyRSwrQ0FBK0M7SUFDL0MsTUFBTSxDQUFDUSxlQUFlQyxpQkFBaUIsR0FBR1QsK0NBQVFBLENBQVMsRUFBRTtJQUM3RCxNQUFNLENBQUNVLFdBQVdDLGFBQWEsR0FBR1gsK0NBQVFBLENBQWEsRUFBRTtJQUN6RCxNQUFNLENBQUNZLFlBQVlDLGNBQWMsR0FBR2IsK0NBQVFBLENBQWMsSUFBSWM7SUFDOUQsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHaEIsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDaUIscUJBQXFCQyx1QkFBdUIsR0FBR2xCLCtDQUFRQSxDQUFTLEVBQUU7SUFDekUsTUFBTSxDQUFDbUIsU0FBU0MsV0FBVyxHQUFHcEIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDcUIsc0JBQXNCQyx3QkFBd0IsR0FBR3RCLCtDQUFRQSxDQUFjO0lBQzlFLE1BQU11QixpQkFBaUJ4Qiw2Q0FBTUEsQ0FBZ0I7SUFFN0MsZ0NBQWdDO0lBQ2hDLE1BQU15QixZQUFZO1FBQ2hCLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQztJQUM5QjtJQUVBLHNFQUFzRTtJQUN0RSxNQUFNQyw0QkFBNEIsT0FDaENDLFFBQ0FDLHNCQUNBQztRQUVBLElBQUk7Z0JBc0RxQkQ7WUFyRHZCRSxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLGlEQUF1Q0gscUJBQXFCSSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7WUFFdkYsSUFBSU4scUJBQXFCTyxNQUFNLEtBQUssR0FBRztnQkFDckNMLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPLEVBQUU7WUFDWDtZQUVBLCtDQUErQztZQUMvQyxNQUFNSyxnQkFBZ0IsSUFBSXZCO1lBQzFCLE1BQU13QixtQkFBbUIsSUFBSXhCO1lBRTdCZSxxQkFBcUJVLE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQzNCQTtpQkFBQUEsYUFBQUEsS0FBS0MsSUFBSSxjQUFURCxpQ0FBQUEsV0FBV0QsT0FBTyxDQUFDRyxDQUFBQSxNQUFPTCxjQUFjTSxHQUFHLENBQUNELElBQUlFLFdBQVc7Z0JBQzNETixpQkFBaUJLLEdBQUcsQ0FBQ0gsS0FBS0ssTUFBTSxDQUFDRCxXQUFXO1lBQzlDO1lBRUFiLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBdUJjLE1BQU1DLElBQUksQ0FBQ1Y7WUFDOUNOLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBeUJjLE1BQU1DLElBQUksQ0FBQ1Q7WUFFaEQsb0RBQW9EO1lBQ3BELElBQUlVLFlBQVk5QyxXQUFXK0MsT0FBTztZQUNsQyxJQUFJLENBQUNELFdBQVc7Z0JBQ2QsTUFBTSxFQUFFRSxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU10RCxtREFBUUEsQ0FDbkNrRCxJQUFJLENBQUMsU0FDTEssTUFBTSxDQUFDO2dCQUNWLElBQUlELE9BQU87b0JBQ1RwQixRQUFRb0IsS0FBSyxDQUFDLHFEQUFxREE7b0JBQ25FLE9BQU8sRUFBRTtnQkFDWDtnQkFDQSxJQUFJLENBQUNELFFBQVFBLEtBQUtkLE1BQU0sS0FBSyxHQUFHO29CQUM5QkwsUUFBUXNCLElBQUksQ0FBQztvQkFDYixPQUFPLEVBQUU7Z0JBQ1g7Z0JBQ0FMLFlBQVlFO2dCQUNaaEQsV0FBVytDLE9BQU8sR0FBR0M7WUFDdkI7WUFFQSxJQUFJSSxpQkFBaUJuRCxnQkFBZ0I4QyxPQUFPO1lBQzVDLElBQUksQ0FBQ0ssZ0JBQWdCO2dCQUNuQixNQUFNLEVBQUVKLE1BQU1LLFNBQVMsRUFBRSxHQUFHLE1BQU0xRCxtREFBUUEsQ0FDdkNrRCxJQUFJLENBQUMsZUFDTEssTUFBTSxDQUFDLFdBQ1BJLEVBQUUsQ0FBQyxXQUFXNUI7Z0JBQ2pCMEIsaUJBQWlCLElBQUl4QztnQkFDckIsSUFBSXlDLFdBQVc7b0JBQ2JBLFVBQVVoQixPQUFPLENBQUNrQixDQUFBQSxPQUFRSCxlQUFnQlgsR0FBRyxDQUFDYyxLQUFLQyxPQUFPO2dCQUM1RDtnQkFDQXZELGdCQUFnQjhDLE9BQU8sR0FBR0s7WUFDNUI7WUFFQSxxRUFBcUU7WUFDckUsNERBQTREO1lBQzVELE1BQU1LLGtCQUFpQjlCLHlCQUFBQSxvQkFBb0IsQ0FBQyxFQUFFLGNBQXZCQSw2Q0FBQUEsdUJBQXlCK0IsUUFBUTtZQUN4RCxNQUFNQyxpQkFBaUJiLFVBQVVjLE1BQU0sQ0FBQyxDQUFDdEI7Z0JBQ3ZDLE9BQ0UsQ0FBQ1YsYUFBYWlDLEdBQUcsQ0FBQ3ZCLEtBQUt3QixPQUFPLENBQUNDLFFBQVEsT0FDdkN6QixLQUFLb0IsUUFBUSxLQUFLRDtZQUV0QjtZQUVBNUIsUUFBUUMsR0FBRyxDQUFDLHFFQUErRTZCLE9BQXBCRixnQkFBZSxPQUEyQixPQUF0QkUsZUFBZXpCLE1BQU07WUFFaEgsSUFBSXlCLGVBQWV6QixNQUFNLEtBQUssR0FBRztnQkFDL0JMLFFBQVFzQixJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFO1lBQ1g7WUFFQSxvREFBb0Q7WUFDcEQsTUFBTWEsY0FBY0wsZUFBZTVCLEdBQUcsQ0FBQyxDQUFDTztvQkFJckJBO2dCQUhqQixJQUFJMkIsUUFBUTtnQkFFWixrREFBa0Q7Z0JBQ2xELE1BQU1DLFdBQVc1QixFQUFBQSxhQUFBQSxLQUFLQyxJQUFJLGNBQVRELGlDQUFBQSxXQUFXUCxHQUFHLENBQUMsQ0FBQ1MsTUFBZ0JBLElBQUlFLFdBQVcsUUFBTyxFQUFFO2dCQUN6RSxNQUFNeUIsZUFBZUQsU0FBU04sTUFBTSxDQUFDLENBQUNwQixNQUFnQkwsY0FBYzBCLEdBQUcsQ0FBQ3JCO2dCQUN4RXlCLFNBQVNFLGFBQWFqQyxNQUFNLEdBQUcsSUFBSSxpQ0FBaUM7Z0JBRXBFLHFEQUFxRDtnQkFDckQsSUFBSUUsaUJBQWlCeUIsR0FBRyxDQUFDdkIsS0FBS0ssTUFBTSxDQUFDRCxXQUFXLEtBQUs7b0JBQ25EdUIsU0FBUyxJQUFJLG9DQUFvQztnQkFDbkQ7Z0JBRUEsbURBQW1EO2dCQUNuRCxNQUFNRyxvQkFBb0J6QyxxQkFBcUJJLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTBCLFFBQVE7Z0JBQ2xFLElBQUlVLGtCQUFrQkMsUUFBUSxDQUFDL0IsS0FBS29CLFFBQVEsR0FBRztvQkFDN0NPLFNBQVM7Z0JBQ1g7Z0JBRUEscUNBQXFDO2dCQUNyQ0EsU0FBU0ssS0FBS3hDLEdBQUcsQ0FBQyxJQUFLUSxDQUFBQSxLQUFLaUMsS0FBSyxJQUFJLE1BQU07Z0JBQzNDTixTQUFTSyxLQUFLeEMsR0FBRyxDQUFDLElBQUtRLENBQUFBLEtBQUtrQyxLQUFLLElBQUksTUFBTTtnQkFFM0Msd0JBQXdCO2dCQUN4QixJQUFJcEIsZUFBZVMsR0FBRyxDQUFDdkIsS0FBS3dCLE9BQU8sR0FBRztvQkFDcENHLFNBQVM7Z0JBQ1g7Z0JBRUEsMkNBQTJDO2dCQUMzQ0EsU0FBU0ssS0FBS0csTUFBTSxLQUFLO2dCQUV6QixPQUFPO29CQUNMbkMsTUFBTW9DLG9CQUFvQnBDLE1BQU1jLGVBQWVTLEdBQUcsQ0FBQ3ZCLEtBQUt3QixPQUFPO29CQUMvREc7Z0JBQ0Y7WUFDRjtZQUVBLCtDQUErQztZQUMvQyxNQUFNVSxrQkFBa0JYLFlBQ3JCWSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWIsS0FBSyxHQUFHWSxFQUFFWixLQUFLLEVBQ2hDYyxLQUFLLENBQUMsR0FBRyxJQUFJLDZCQUE2QjthQUMxQ2hELEdBQUcsQ0FBQ2lELENBQUFBLFFBQVNBLE1BQU0xQyxJQUFJO1lBRTFCVCxRQUFRQyxHQUFHLENBQUMsbUVBQ1Y2QyxnQkFBZ0JJLEtBQUssQ0FBQyxHQUFHLEdBQUdoRCxHQUFHLENBQUNDLENBQUFBLElBQUssR0FBZ0JBLE9BQWJBLEVBQUVDLElBQUksRUFBQyxRQUFlLE9BQVRELEVBQUVXLE1BQU07WUFFL0QsT0FBT2dDO1FBRVQsRUFBRSxPQUFPMUIsT0FBTztZQUNkcEIsUUFBUW9CLEtBQUssQ0FBQyx5Q0FBeUNBO1lBQ3ZELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSwwQ0FBMEM7SUFDMUMsTUFBTXlCLHNCQUFzQixTQUFDTztZQUFzQkMsMkVBQW1CO2VBQWlCO1lBQ3JGcEIsU0FBU21CLE9BQU9uQixPQUFPO1lBQ3ZCcUIsUUFBUUYsT0FBT0UsTUFBTTtZQUNyQmxELE1BQU1nRCxPQUFPaEQsSUFBSTtZQUNqQlUsUUFBUXNDLE9BQU90QyxNQUFNO1lBQ3JCZSxVQUFVdUIsT0FBT3ZCLFFBQVE7WUFDekJuQixNQUFNMEMsT0FBTzFDLElBQUk7WUFDakJpQyxPQUFPUyxPQUFPVCxLQUFLO1lBQ25CRCxPQUFPVSxPQUFPVixLQUFLO1lBQ25CYSxJQUFJSCxPQUFPbkIsT0FBTyxDQUFDQyxRQUFRO1lBQzNCc0IsT0FBTyxvQ0FBa0VKLE9BQTlCQSxPQUFPRSxNQUFNLEVBQUMsa0JBQThCLE9BQWRGLE9BQU9FLE1BQU0sRUFBQztZQUN2RkQ7UUFDRjs7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTUksYUFBYTtRQUNqQixNQUFNNUQsU0FBU0o7UUFDZixJQUFJLENBQUNJLFFBQVE7WUFDWHZCLFNBQVMsRUFBRTtZQUNYRSxxQkFBcUIsRUFBRTtZQUN2QkUsaUJBQWlCLEVBQUU7WUFDbkI7UUFDRjtRQUVBLElBQUk7WUFDRnNCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRWtCLE1BQU1GLFNBQVMsRUFBRUcsS0FBSyxFQUFFLEdBQUcsTUFBTXRELG1EQUFRQSxDQUM5Q2tELElBQUksQ0FBQyxTQUNMSyxNQUFNLENBQUMsS0FDUHFDLEtBQUssQ0FBQyxTQUFTO2dCQUFFQyxXQUFXO1lBQU07WUFDckMsSUFBSXZDLE9BQU8sTUFBTUE7WUFDakJwQixRQUFRQyxHQUFHLENBQUMsa0JBQWtCZ0Isc0JBQUFBLGdDQUFBQSxVQUFXWixNQUFNO1lBRS9DLG9CQUFvQjtZQUNwQixJQUFJa0IsaUJBQWlCLElBQUl4QztZQUN6QixNQUFNLEVBQUVvQyxNQUFNSyxTQUFTLEVBQUUsR0FBRyxNQUFNMUQsbURBQVFBLENBQ3ZDa0QsSUFBSSxDQUFDLGVBQ0xLLE1BQU0sQ0FBQyxXQUNQSSxFQUFFLENBQUMsV0FBVzVCO1lBQ2pCLElBQUkyQixXQUFXO2dCQUNiRCxpQkFBaUIsSUFBSXhDLElBQUl5QyxVQUFVdEIsR0FBRyxDQUFDd0IsQ0FBQUEsT0FBUUEsS0FBS0MsT0FBTztnQkFDM0Q3QyxjQUFjeUM7WUFDaEI7WUFFQSw0Q0FBNEM7WUFDNUMsTUFBTSxFQUFFSixNQUFNeUMsV0FBVyxFQUFFeEMsT0FBT3lDLFlBQVksRUFBRSxHQUFHLE1BQU0vRixtREFBUUEsQ0FDOURrRCxJQUFJLENBQUMsV0FDTEssTUFBTSxDQUFDLHVDQUNQSSxFQUFFLENBQUMsV0FBVzVCLFFBQ2Q2RCxLQUFLLENBQUMsb0JBQW9CO2dCQUFFQyxXQUFXO1lBQU07WUFDaEQsSUFBSUUsY0FBYyxNQUFNQTtZQUN4QjdELFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUIyRCx3QkFBQUEsa0NBQUFBLFlBQWF2RCxNQUFNO1lBRXhELDhDQUE4QztZQUM5QyxNQUFNeUQsYUFBYSxDQUFDRixlQUFlLEVBQUUsRUFBRVYsS0FBSyxDQUFDLEdBQUcsSUFBSW5CLE1BQU0sQ0FBQ2dDLENBQUFBLElBQUtBLEVBQUUxRixLQUFLO1lBQ3ZFLHVDQUF1QztZQUN2QyxNQUFNMkYsV0FBbUMsQ0FBQztZQUMxQyxNQUFNQyxjQUFzQyxDQUFDO1lBQzdDSCxXQUFXdEQsT0FBTyxDQUFDdUQsQ0FBQUE7Z0JBQ2pCLHdEQUF3RDtnQkFDeEQsTUFBTUcsVUFBVW5ELE1BQU1vRCxPQUFPLENBQUNKLEVBQUUxRixLQUFLLElBQUkwRixFQUFFMUYsS0FBSyxDQUFDLEVBQUUsR0FBRzBGLEVBQUUxRixLQUFLO2dCQUM1RDZGLENBQUFBLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU3hELElBQUksS0FBSSxFQUFFLEVBQUVGLE9BQU8sQ0FBQyxDQUFDRztvQkFDN0IsTUFBTXlELElBQUl6RCxJQUFJRSxXQUFXO29CQUN6Qm1ELFFBQVEsQ0FBQ0ksRUFBRSxHQUFHLENBQUNKLFFBQVEsQ0FBQ0ksRUFBRSxJQUFJLEtBQUs7Z0JBQ3JDO2dCQUNBLElBQUlGLG9CQUFBQSw4QkFBQUEsUUFBU3BELE1BQU0sRUFBRTtvQkFDbkIsTUFBTWtDLElBQUlrQixRQUFRcEQsTUFBTSxDQUFDRCxXQUFXO29CQUNwQ29ELFdBQVcsQ0FBQ2pCLEVBQUUsR0FBRyxDQUFDaUIsV0FBVyxDQUFDakIsRUFBRSxJQUFJLEtBQUs7Z0JBQzNDO1lBQ0Y7WUFDQSxvQ0FBb0M7WUFDcEMsTUFBTXFCLGFBQWFDLE9BQU9DLE9BQU8sQ0FBQ1AsVUFDL0JqQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsRUFDMUJFLEtBQUssQ0FBQyxHQUFHLEdBQ1RoRCxHQUFHLENBQUM7b0JBQUMsQ0FBQ1MsSUFBSTt1QkFBS0E7O1lBQ2xCLE1BQU02RCxnQkFBZ0JGLE9BQU9DLE9BQU8sQ0FBQ04sYUFDbENsQixJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsQ0FBQyxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUUsRUFDMUJFLEtBQUssQ0FBQyxHQUFHLEdBQ1RoRCxHQUFHLENBQUM7b0JBQUMsQ0FBQ1ksT0FBTzt1QkFBS0E7O1lBQ3JCZCxRQUFRQyxHQUFHLENBQUMsdUJBQXVCb0U7WUFDbkNyRSxRQUFRQyxHQUFHLENBQUMsMEJBQTBCdUU7WUFFdEMsK0NBQStDO1lBQy9DLE1BQU1DLGlCQUFpQixJQUFJMUYsSUFBSSxDQUFDNkUsZUFBZSxFQUFFLEVBQUUxRCxHQUFHLENBQUM2RCxDQUFBQTtvQkFBS0E7d0JBQUFBLGFBQUFBLEVBQUVwQyxPQUFPLGNBQVRvQyxpQ0FBQUEsV0FBVzdCLFFBQVE7O1lBRS9FLG9CQUFvQjtZQUNwQixNQUFNd0MsaUJBQWlCekQsQ0FBQUEsc0JBQUFBLGdDQUFBQSxVQUFXZixHQUFHLENBQUNPLENBQUFBLE9BQ3BDb0Msb0JBQW9CcEMsTUFBTWMsZUFBZVMsR0FBRyxDQUFDdkIsS0FBS3dCLE9BQU8sUUFDdEQsRUFBRTtZQUVQM0QsU0FBU29HLGlCQUFpQiwyQ0FBMkM7WUFFckUsb0RBQW9EO1lBQ3BELE1BQU1DLGdCQUFnQkQsZUFBZTNDLE1BQU0sQ0FBQ3RCLENBQUFBLE9BQVEsQ0FBQ2dFLGVBQWV6QyxHQUFHLENBQUN2QixLQUFLOEMsRUFBRTtZQUUvRSxrQ0FBa0M7WUFDbEMsTUFBTXBCLGNBQWN3QyxjQUFjekUsR0FBRyxDQUFDTyxDQUFBQTtnQkFDcEMsSUFBSTJCLFFBQVE7Z0JBQ1osWUFBWTtnQkFDWixNQUFNQyxXQUFXLENBQUM1QixLQUFLQyxJQUFJLElBQUksRUFBRSxFQUFFUixHQUFHLENBQUMsQ0FBQ2tFLElBQWNBLEVBQUV2RCxXQUFXO2dCQUNuRXVCLFNBQVNDLFNBQVNOLE1BQU0sQ0FBQ3FDLENBQUFBLElBQUtDLFdBQVc3QixRQUFRLENBQUM0QixJQUFJL0QsTUFBTSxHQUFHO2dCQUMvRCxlQUFlO2dCQUNmLElBQUlJLEtBQUtLLE1BQU0sSUFBSTBELGNBQWNoQyxRQUFRLENBQUMvQixLQUFLSyxNQUFNLENBQUNELFdBQVcsS0FBSztvQkFDcEV1QixTQUFTO2dCQUNYO2dCQUNBLGFBQWE7Z0JBQ2JBLFNBQVMsQ0FBQzNCLEtBQUtrQyxLQUFLLElBQUksS0FBTWxDLENBQUFBLEtBQUtpQyxLQUFLLElBQUk7Z0JBQzVDLE9BQU87b0JBQUVqQztvQkFBTTJCO2dCQUFNO1lBQ3ZCO1lBQ0EsMkJBQTJCO1lBQzNCLE1BQU13QyxxQkFBcUJ6QyxZQUFZWSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWIsS0FBSyxHQUFHWSxFQUFFWixLQUFLLEVBQUVsQyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVNLElBQUk7WUFFeEZqQyxxQkFBcUJvRztZQUVyQixzRUFBc0U7WUFDdEUsTUFBTUMsV0FBVzttQkFBSUg7YUFBZSxDQUNqQzNCLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLEVBQUdOLEtBQUssR0FBR00sRUFBRVAsS0FBSyxHQUFLTSxDQUFBQSxFQUFFTCxLQUFLLEdBQUdLLEVBQUVOLEtBQUssR0FDdkRRLEtBQUssQ0FBQyxHQUFHO1lBQ1p4RSxpQkFBaUJtRztZQUNqQjdFLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUI0RSxTQUFTM0UsR0FBRyxDQUFDQyxDQUFBQSxJQUFLLEdBQWNBLE9BQVhBLEVBQUVDLElBQUksRUFBQyxNQUFzQkQsT0FBbEJBLEVBQUV3QyxLQUFLLEVBQUMsWUFBa0IsT0FBUnhDLEVBQUV1QyxLQUFLLEVBQUM7WUFFekYsaUNBQWlDO1lBQ2pDLE1BQU0sRUFBRXZCLE1BQU0yRCxRQUFRLEVBQUUsR0FBRyxNQUFNaEgsbURBQVFBLENBQ3RDa0QsSUFBSSxDQUFDLFNBQ0xLLE1BQU0sQ0FBQyxxQkFDUEksRUFBRSxDQUFDLE1BQU01QixRQUNUa0YsTUFBTTtZQUNULElBQUlELHFCQUFBQSwrQkFBQUEsU0FBVUUsaUJBQWlCLEVBQUU7Z0JBQy9CLE1BQU1DLFdBQVdQLGVBQWVRLElBQUksQ0FBQ3pFLENBQUFBLE9BQVFBLEtBQUt3QixPQUFPLEtBQUs2QyxTQUFTRSxpQkFBaUI7Z0JBQ3hGLElBQUlDLFVBQVU7b0JBQ1poRyxrQkFBa0JnRztnQkFDcEI7WUFDRjtRQUNGLEVBQUUsT0FBTzdELE9BQU87WUFDZHBCLFFBQVFvQixLQUFLLENBQUMseUJBQXlCQTtZQUN2QzlDLFNBQVMsRUFBRTtRQUNiO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEUsTUFBTTZHLHVCQUF1QixPQUFPdEYsUUFBZ0J1RixhQUFtQkM7UUFDckUsSUFBSTtZQUNGckYsUUFBUUMsR0FBRyxDQUFDLGlEQUF1Q21GLFlBQVloRixJQUFJO1lBQ25FSixRQUFRQyxHQUFHLENBQUMsc0NBQTRCb0YsQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlQyxJQUFJLEtBQUk7WUFFL0QseUNBQXlDO1lBQ3pDLElBQUlyRSxZQUFZOUMsV0FBVytDLE9BQU87WUFDbEMsSUFBSSxDQUFDRCxXQUFXO2dCQUNkLE1BQU0sRUFBRUUsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNdEQsbURBQVFBLENBQ25Da0QsSUFBSSxDQUFDLFNBQ0xLLE1BQU0sQ0FBQztnQkFDVixJQUFJRCxPQUFPO29CQUNUcEIsUUFBUW9CLEtBQUssQ0FBQywrQ0FBK0NBO29CQUM3RCxPQUFPLEVBQUU7Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFDRCxRQUFRQSxLQUFLZCxNQUFNLEtBQUssR0FBRztvQkFDOUJMLFFBQVFzQixJQUFJLENBQUM7b0JBQ2IsT0FBTyxFQUFFO2dCQUNYO2dCQUNBTCxZQUFZRTtnQkFDWmhELFdBQVcrQyxPQUFPLEdBQUdDO1lBQ3ZCO1lBRUEsOEVBQThFO1lBQzlFLE1BQU0sRUFBRUEsTUFBTXlDLFdBQVcsRUFBRXhDLE9BQU95QyxZQUFZLEVBQUUsR0FBRyxNQUFNL0YsbURBQVFBLENBQzlEa0QsSUFBSSxDQUFDLFdBQ0xLLE1BQU0sQ0FBQyw2QkFDUEksRUFBRSxDQUFDLFdBQVc1QjtZQUNqQixJQUFJZ0UsY0FBYztnQkFDaEI3RCxRQUFRb0IsS0FBSyxDQUFDLDZCQUE2QnlDO1lBQzdDO1lBQ0EsTUFBTTBCLGFBQWEsSUFBSUM7WUFDdkIsSUFBSTVCLGFBQWE7Z0JBQ2ZBLFlBQVlwRCxPQUFPLENBQUN1RCxDQUFBQSxJQUFLd0IsV0FBV0UsR0FBRyxDQUFDMUIsRUFBRXBDLE9BQU8sRUFBRW9DLEVBQUUyQixnQkFBZ0IsSUFBSTtZQUMzRTtZQUVBLGdEQUFnRDtZQUNoRCxJQUFJbkUsaUJBQWlCbkQsZ0JBQWdCOEMsT0FBTztZQUM1QyxJQUFJLENBQUNLLGdCQUFnQjtnQkFDbkIsTUFBTSxFQUFFSixNQUFNSyxTQUFTLEVBQUUsR0FBRyxNQUFNMUQsbURBQVFBLENBQ3ZDa0QsSUFBSSxDQUFDLGVBQ0xLLE1BQU0sQ0FBQyxXQUNQSSxFQUFFLENBQUMsV0FBVzVCO2dCQUNqQjBCLGlCQUFpQixJQUFJeEM7Z0JBQ3JCLElBQUl5QyxXQUFXO29CQUNiQSxVQUFVaEIsT0FBTyxDQUFDa0IsQ0FBQUEsT0FBUUgsZUFBZ0JYLEdBQUcsQ0FBQ2MsS0FBS0MsT0FBTztnQkFDNUQ7Z0JBQ0F2RCxnQkFBZ0I4QyxPQUFPLEdBQUdLO1lBQzVCO1lBRUEsa0RBQWtEO1lBQ2xELE1BQU1LLGlCQUFpQndELFlBQVl2RCxRQUFRO1lBQzNDLE1BQU1DLGlCQUFpQmIsVUFBVWMsTUFBTSxDQUFDLENBQUN0QjtnQkFDdkMsdUJBQXVCO2dCQUN2QixJQUFJQSxLQUFLd0IsT0FBTyxLQUFLbUQsWUFBWW5ELE9BQU8sRUFBRTtvQkFDeEMsT0FBTztnQkFDVDtnQkFDQSxxQ0FBcUM7Z0JBQ3JDLElBQUlvRCxpQkFBaUJBLGNBQWNyRCxHQUFHLENBQUN2QixLQUFLd0IsT0FBTyxDQUFDQyxRQUFRLEtBQUs7b0JBQy9EbEMsUUFBUUMsR0FBRyxDQUFDLHlDQUErQ1EsT0FBaEJBLEtBQUtMLElBQUksRUFBQyxRQUFrQixPQUFaSyxLQUFLSyxNQUFNO29CQUN0RSxPQUFPO2dCQUNUO2dCQUNBLDREQUE0RDtnQkFDNUQsSUFBSUwsS0FBS29CLFFBQVEsS0FBS0QsZ0JBQWdCO29CQUNwQyxPQUFPO2dCQUNUO2dCQUNBLE9BQU87WUFDVDtZQUVBNUIsUUFBUUMsR0FBRyxDQUFDLDJEQUFxRTZCLE9BQXBCRixnQkFBZSxPQUEyQixPQUF0QkUsZUFBZXpCLE1BQU07WUFFdEcsSUFBSXlCLGVBQWV6QixNQUFNLEtBQUssR0FBRztnQkFDL0JMLFFBQVFzQixJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFO1lBQ1g7WUFFQSwwQkFBMEI7WUFDMUIsTUFBTWEsY0FBY0wsZUFBZTVCLEdBQUcsQ0FBQyxDQUFDTztvQkFJakJBO2dCQUhyQixJQUFJMkIsUUFBUTtnQkFFWixrQ0FBa0M7Z0JBQ2xDLE1BQU1FLGVBQWU3QixFQUFBQSxhQUFBQSxLQUFLQyxJQUFJLGNBQVRELGlDQUFBQSxXQUFXc0IsTUFBTSxDQUFDLENBQUNwQjt3QkFDdEN5RTs0QkFBQUEsb0JBQUFBLFlBQVkxRSxJQUFJLGNBQWhCMEUsd0NBQUFBLGtCQUFrQjVDLFFBQVEsQ0FBQzdCO3VCQUN4QixFQUFFO2dCQUNQeUIsU0FBU0UsYUFBYWpDLE1BQU0sR0FBRztnQkFFL0Isa0JBQWtCO2dCQUNsQixJQUFJSSxLQUFLSyxNQUFNLEtBQUtzRSxZQUFZdEUsTUFBTSxFQUFFO29CQUN0Q3NCLFNBQVM7Z0JBQ1g7Z0JBRUEsb0JBQW9CO2dCQUNwQixJQUFJM0IsS0FBS29CLFFBQVEsS0FBS3VELFlBQVl2RCxRQUFRLEVBQUU7b0JBQzFDTyxTQUFTO2dCQUNYO2dCQUVBLDBCQUEwQjtnQkFDMUIsTUFBTXVELGtCQUFrQkosV0FBV0ssR0FBRyxDQUFDbkYsS0FBS3dCLE9BQU8sS0FBSztnQkFDeERHLFNBQVNLLEtBQUtvRCxHQUFHLENBQUNGLGtCQUFrQixHQUFHLEtBQUssbUJBQW1CO2dCQUUvRCxxQ0FBcUM7Z0JBQ3JDdkQsU0FBU0ssS0FBS3hDLEdBQUcsQ0FBQyxJQUFLUSxDQUFBQSxLQUFLaUMsS0FBSyxJQUFJLE1BQU07Z0JBQzNDTixTQUFTSyxLQUFLeEMsR0FBRyxDQUFDLElBQUtRLENBQUFBLEtBQUtrQyxLQUFLLElBQUksTUFBTTtnQkFFM0Msb0JBQW9CO2dCQUNwQixJQUFJcEIsZUFBZVMsR0FBRyxDQUFDdkIsS0FBS3dCLE9BQU8sR0FBRztvQkFDcENHLFNBQVM7Z0JBQ1g7Z0JBRUEsZ0RBQWdEO2dCQUNoREEsU0FBU0ssS0FBS0csTUFBTSxLQUFLO2dCQUV6QixPQUFPO29CQUNMbkMsTUFBTW9DLG9CQUFvQnBDLE1BQU1jLGVBQWVTLEdBQUcsQ0FBQ3ZCLEtBQUt3QixPQUFPO29CQUMvREc7Z0JBQ0Y7WUFDRjtZQUVBLGtEQUFrRDtZQUNsRCxNQUFNVSxrQkFBa0JYLFlBQ3JCWSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRWIsS0FBSyxHQUFHWSxFQUFFWixLQUFLLEVBQ2hDYyxLQUFLLENBQUMsR0FBRyxJQUFJLGtDQUFrQzthQUMvQ2hELEdBQUcsQ0FBQ2lELENBQUFBLFFBQVNBLE1BQU0xQyxJQUFJO1lBRTFCVCxRQUFRQyxHQUFHLENBQUMsOENBQW9DNkMsZ0JBQWdCSSxLQUFLLENBQUMsR0FBRyxHQUFHaEQsR0FBRyxDQUFDQyxDQUFBQSxJQUFLLEdBQWdCQSxPQUFiQSxFQUFFQyxJQUFJLEVBQUMsUUFBZSxPQUFURCxFQUFFVyxNQUFNO1lBQzdHZCxRQUFRQyxHQUFHLENBQUMsdUNBQTZCNkIsZUFBZXpCLE1BQU07WUFFOUQsT0FBT3lDO1FBRVQsRUFBRSxPQUFPMUIsT0FBTztZQUNkcEIsUUFBUW9CLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQSx5REFBeUQ7SUFDekQsTUFBTTBFLHNCQUFzQjtRQUMxQixNQUFNakcsU0FBU0o7UUFDZixJQUFJLENBQUNJLFFBQVE7WUFDWFYsdUJBQXVCLEVBQUU7WUFDekI7UUFDRjtRQUVBLElBQUk7WUFDRiwwREFBMEQ7WUFDMUQsTUFBTSxFQUFFZ0MsTUFBTXlDLFdBQVcsRUFBRXhDLE9BQU95QyxZQUFZLEVBQUUsR0FBRyxNQUFNL0YsbURBQVFBLENBQzlEa0QsSUFBSSxDQUFDLFdBQ0xLLE1BQU0sQ0FBRSxvRkFLUkksRUFBRSxDQUFDLFdBQVc1QixRQUNkNkQsS0FBSyxDQUFDLG9CQUFvQjtnQkFBRUMsV0FBVztZQUFNLEdBQzdDb0MsS0FBSyxDQUFDO1lBRVQsSUFBSWxDLGNBQWM7Z0JBQ2hCN0QsUUFBUW9CLEtBQUssQ0FBQyxtQ0FBbUN5QztnQkFDakQ7WUFDRjtZQUVBLElBQUksQ0FBQ0QsZUFBZUEsWUFBWXZELE1BQU0sS0FBSyxHQUFHO2dCQUM1Q2xCLHVCQUF1QixFQUFFO2dCQUN6QjtZQUNGO1lBRUEsK0NBQStDO1lBQy9DLE1BQU0sRUFBRWdDLE1BQU1LLFNBQVMsRUFBRSxHQUFHLE1BQU0xRCxtREFBUUEsQ0FDdkNrRCxJQUFJLENBQUMsZUFDTEssTUFBTSxDQUFDLFdBQ1BJLEVBQUUsQ0FBQyxXQUFXNUI7WUFFakIsTUFBTTBCLGlCQUFpQixJQUFJeEM7WUFDM0IsSUFBSXlDLFdBQVc7Z0JBQ2JBLFVBQVVoQixPQUFPLENBQUNrQixDQUFBQSxPQUFRSCxlQUFlWCxHQUFHLENBQUNjLEtBQUtDLE9BQU87WUFDM0Q7WUFFQSx5QkFBeUI7WUFDekIsTUFBTXFFLGNBQWNwQyxZQUNqQjdCLE1BQU0sQ0FBQ0wsQ0FBQUEsT0FBUUEsS0FBS3JELEtBQUssRUFBRSwwQkFBMEI7YUFDckQ2QixHQUFHLENBQUN3QixDQUFBQTtnQkFDSCxNQUFNd0MsVUFBVW5ELE1BQU1vRCxPQUFPLENBQUN6QyxLQUFLckQsS0FBSyxJQUFJcUQsS0FBS3JELEtBQUssQ0FBQyxFQUFFLEdBQUdxRCxLQUFLckQsS0FBSztnQkFDdEUsT0FBT3dFLG9CQUFvQnFCLFNBQVMzQyxlQUFlUyxHQUFHLENBQUNOLEtBQUtDLE9BQU87WUFDckU7WUFFRnhDLHVCQUF1QjZHO1FBQ3pCLEVBQUUsT0FBTzVFLE9BQU87WUFDZHBCLFFBQVFvQixLQUFLLENBQUMseUNBQXlDQTtZQUN2RGpDLHVCQUF1QixFQUFFO1FBQzNCO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTThHLGlCQUFpQjtRQUNyQixNQUFNcEcsU0FBU0o7UUFDZixJQUFJLENBQUNJLFFBQVE7WUFDWGpCLGFBQWEsRUFBRTtZQUNmO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsTUFBTSxFQUFFdUMsTUFBTStFLGFBQWEsRUFBRTlFLEtBQUssRUFBRSxHQUFHLE1BQU10RCxtREFBUUEsQ0FDbERrRCxJQUFJLENBQUMsYUFDTEssTUFBTSxDQUFFLDhHQU9SSSxFQUFFLENBQUMsV0FBVzVCO1lBRWpCLElBQUl1QixPQUFPLE1BQU1BO1lBRWpCLE1BQU0rRSxxQkFBaUNELENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZWhHLEdBQUcsQ0FBQ2tHLENBQUFBO29CQUNsQ0EsMEJBUWJDO2dCQVJULE1BQU1BLGdCQUFnQkQsRUFBQUEsMkJBQUFBLFNBQVNFLGNBQWMsY0FBdkJGLCtDQUFBQSx5QkFBeUJsRyxHQUFHLENBQUMsQ0FBQ3FHLEtBQ2xEMUQsb0JBQW9CMEQsR0FBR2xJLEtBQUssRUFBRVEsV0FBV21ELEdBQUcsQ0FBQ3VFLEdBQUdsSSxLQUFLLENBQUM0RCxPQUFPLFFBQzFELEVBQUU7Z0JBRVAsT0FBTztvQkFDTHNCLElBQUk2QyxTQUFTN0MsRUFBRSxDQUFDckIsUUFBUTtvQkFDeEI5QixNQUFNZ0csU0FBU2hHLElBQUk7b0JBQ25Cb0csV0FBV0gsY0FBY2hHLE1BQU07b0JBQy9CbUQsT0FBTzZDLEVBQUFBLGtCQUFBQSxhQUFhLENBQUMsRUFBRSxjQUFoQkEsc0NBQUFBLGdCQUFrQjdDLEtBQUssS0FBSTtvQkFDbENuRixPQUFPZ0k7Z0JBQ1Q7WUFDRixPQUFNLEVBQUU7WUFFUnpILGFBQWF1SDtRQUNmLEVBQUUsT0FBTy9FLE9BQU87WUFDZHBCLFFBQVFvQixLQUFLLENBQUMsNkJBQTZCQTtRQUM3QztJQUNGO0lBRUEsbUJBQW1CO0lBQ25CLE1BQU1xRixhQUFhLE9BQU9DO1FBQ3hCLE1BQU03RyxTQUFTSjtRQUNmLElBQUksQ0FBQ0ksUUFBUTtRQUViLE1BQU04RyxhQUFhQyxTQUFTRjtRQUM1QixNQUFNRyxtQkFBbUJoSSxXQUFXbUQsR0FBRyxDQUFDMkU7UUFFeEMsSUFBSTtZQUNGLElBQUlFLGtCQUFrQjtnQkFDcEIsMEJBQTBCO2dCQUMxQixNQUFNLEVBQUV6RixLQUFLLEVBQUUsR0FBRyxNQUFNdEQsbURBQVFBLENBQzdCa0QsSUFBSSxDQUFDLGVBQ0w4RixNQUFNLEdBQ05yRixFQUFFLENBQUMsV0FBVzVCLFFBQ2Q0QixFQUFFLENBQUMsV0FBV2tGO2dCQUVqQixJQUFJdkYsT0FBTyxNQUFNQTtnQkFFakIsa0JBQWtCO2dCQUNsQixNQUFNdEQsbURBQVFBLENBQUNpSixHQUFHLENBQUMsd0JBQXdCO29CQUFFQyxjQUFjTDtnQkFBVztnQkFFdEU3SCxjQUFjbUksQ0FBQUE7b0JBQ1osTUFBTUMsU0FBUyxJQUFJbkksSUFBSWtJO29CQUN2QkMsT0FBT0osTUFBTSxDQUFDSDtvQkFDZCxPQUFPTztnQkFDVDtZQUNGLE9BQU87Z0JBQ0wscUJBQXFCO2dCQUNyQixNQUFNLEVBQUU5RixLQUFLLEVBQUUsR0FBRyxNQUFNdEQsbURBQVFBLENBQzdCa0QsSUFBSSxDQUFDLGVBQ0xtRyxNQUFNLENBQUM7b0JBQ05DLFNBQVN2SDtvQkFDVDhCLFNBQVNnRjtnQkFDWDtnQkFFRixJQUFJdkYsT0FBTyxNQUFNQTtnQkFFakIsa0JBQWtCO2dCQUNsQixNQUFNdEQsbURBQVFBLENBQUNpSixHQUFHLENBQUMsd0JBQXdCO29CQUFFQyxjQUFjTDtnQkFBVztnQkFFdEU3SCxjQUFjbUksQ0FBQUEsT0FBUSxJQUFJbEksSUFBSWtJLE1BQU1yRyxHQUFHLENBQUMrRjtZQUMxQztZQUVBLHFCQUFxQjtZQUNyQnJJLFNBQVMrSSxDQUFBQSxZQUNQQSxVQUFVbkgsR0FBRyxDQUFDTyxDQUFBQSxPQUNaQSxLQUFLOEMsRUFBRSxLQUFLbUQsU0FDUjt3QkFDRSxHQUFHakcsSUFBSTt3QkFDUDRDLFNBQVMsQ0FBQ3dEO3dCQUNWbkUsT0FBT2pDLEtBQUtpQyxLQUFLLEdBQUltRSxDQUFBQSxtQkFBbUIsQ0FBQyxJQUFJO29CQUMvQyxJQUNBcEc7WUFJUix5QkFBeUI7WUFDekI3QixhQUFhMEksQ0FBQUEsZ0JBQ1hBLGNBQWNwSCxHQUFHLENBQUNrRyxDQUFBQSxXQUFhO3dCQUM3QixHQUFHQSxRQUFRO3dCQUNYL0gsT0FBTytILFNBQVMvSCxLQUFLLENBQUM2QixHQUFHLENBQUNPLENBQUFBLE9BQ3hCQSxLQUFLOEMsRUFBRSxLQUFLbUQsU0FDUjtnQ0FDRSxHQUFHakcsSUFBSTtnQ0FDUDRDLFNBQVMsQ0FBQ3dEO2dDQUNWbkUsT0FBT2pDLEtBQUtpQyxLQUFLLEdBQUltRSxDQUFBQSxtQkFBbUIsQ0FBQyxJQUFJOzRCQUMvQyxJQUNBcEc7b0JBRVI7UUFFSixFQUFFLE9BQU9XLE9BQU87WUFDZHBCLFFBQVFvQixLQUFLLENBQUMsd0JBQXdCQTtRQUN4QztJQUNGO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1tRyxpQkFBaUIsT0FBT25IO1FBQzVCLE1BQU1QLFNBQVNKO1FBQ2YsSUFBSSxDQUFDSSxRQUFRO1FBRWIsSUFBSTtZQUNGLE1BQU0sRUFBRXNCLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTXRELG1EQUFRQSxDQUNuQ2tELElBQUksQ0FBQyxhQUNMbUcsTUFBTSxDQUFDO2dCQUNOQyxTQUFTdkg7Z0JBQ1RPO1lBQ0YsR0FDQ2lCLE1BQU0sR0FDTjBELE1BQU07WUFFVCxJQUFJM0QsT0FBTyxNQUFNQTtZQUVqQixNQUFNb0csY0FBd0I7Z0JBQzVCakUsSUFBSXBDLEtBQUtvQyxFQUFFLENBQUNyQixRQUFRO2dCQUNwQjlCLE1BQU1lLEtBQUtmLElBQUk7Z0JBQ2ZvRyxXQUFXO2dCQUNYaEQsT0FBTztnQkFDUG5GLE9BQU8sRUFBRTtZQUNYO1lBRUFPLGFBQWFxSSxDQUFBQSxPQUFRO3VCQUFJQTtvQkFBTU87aUJBQVk7UUFDN0MsRUFBRSxPQUFPcEcsT0FBTztZQUNkcEIsUUFBUW9CLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzVDO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTXFHLGlCQUFpQixPQUFPQztRQUM1QixNQUFNN0gsU0FBU0o7UUFDZixJQUFJLENBQUNJLFFBQVE7UUFFYixJQUFJO1lBQ0YsTUFBTSxFQUFFdUIsS0FBSyxFQUFFLEdBQUcsTUFBTXRELG1EQUFRQSxDQUM3QmtELElBQUksQ0FBQyxhQUNMOEYsTUFBTSxHQUNOckYsRUFBRSxDQUFDLE1BQU1tRixTQUFTYyxhQUNsQmpHLEVBQUUsQ0FBQyxXQUFXNUI7WUFFakIsSUFBSXVCLE9BQU8sTUFBTUE7WUFFakJ4QyxhQUFhcUksQ0FBQUEsT0FBUUEsS0FBS2xGLE1BQU0sQ0FBQ3FFLENBQUFBLFdBQVlBLFNBQVM3QyxFQUFFLEtBQUttRTtRQUMvRCxFQUFFLE9BQU90RyxPQUFPO1lBQ2RwQixRQUFRb0IsS0FBSyxDQUFDLDRCQUE0QkE7UUFDNUM7SUFDRjtJQUVBLGtCQUFrQjtJQUNsQixNQUFNdUcsaUJBQWlCLE9BQU9ELFlBQW9CRTtRQUNoRCxNQUFNL0gsU0FBU0o7UUFDZixJQUFJLENBQUNJLFFBQVE7UUFFYixJQUFJO1lBQ0YsTUFBTSxFQUFFdUIsS0FBSyxFQUFFLEdBQUcsTUFBTXRELG1EQUFRQSxDQUM3QmtELElBQUksQ0FBQyxhQUNMNkcsTUFBTSxDQUFDO2dCQUFFekgsTUFBTXdIO1lBQVEsR0FDdkJuRyxFQUFFLENBQUMsTUFBTW1GLFNBQVNjLGFBQ2xCakcsRUFBRSxDQUFDLFdBQVc1QjtZQUVqQixJQUFJdUIsT0FBTyxNQUFNQTtZQUVqQnhDLGFBQWFxSSxDQUFBQSxPQUNYQSxLQUFLL0csR0FBRyxDQUFDa0csQ0FBQUEsV0FDUEEsU0FBUzdDLEVBQUUsS0FBS21FLGFBQ1o7d0JBQUUsR0FBR3RCLFFBQVE7d0JBQUVoRyxNQUFNd0g7b0JBQVEsSUFDN0J4QjtRQUdWLEVBQUUsT0FBT2hGLE9BQU87WUFDZHBCLFFBQVFvQixLQUFLLENBQUMsNEJBQTRCQTtRQUM1QztJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCLE1BQU0wRyxvQkFBb0IsT0FBT0osWUFBb0JqSDtRQUNuRCxNQUFNWixTQUFTSjtRQUNmLElBQUksQ0FBQ0ksUUFBUTtRQUViLElBQUk7WUFDRixNQUFNLEVBQUV1QixLQUFLLEVBQUUsR0FBRyxNQUFNdEQsbURBQVFBLENBQzdCa0QsSUFBSSxDQUFDLGtCQUNMbUcsTUFBTSxDQUFDO2dCQUNOWSxhQUFhbkIsU0FBU2M7Z0JBQ3RCL0YsU0FBU2xCLEtBQUt3QixPQUFPO1lBQ3ZCO1lBRUYsSUFBSWIsT0FBTyxNQUFNQTtZQUVqQnhDLGFBQWFxSSxDQUFBQSxPQUNYQSxLQUFLL0csR0FBRyxDQUFDa0csQ0FBQUE7b0JBQ1AsSUFBSUEsU0FBUzdDLEVBQUUsS0FBS21FLFlBQVk7d0JBQzlCLE1BQU1NLGFBQWE1QixTQUFTL0gsS0FBSyxDQUFDNEosSUFBSSxDQUFDOUgsQ0FBQUEsSUFBS0EsRUFBRW9ELEVBQUUsS0FBSzlDLEtBQUs4QyxFQUFFO3dCQUM1RCxJQUFJLENBQUN5RSxZQUFZO2dDQU1ORTs0QkFMVCxNQUFNQSxlQUFlO21DQUFJOUIsU0FBUy9ILEtBQUs7Z0NBQUVvQzs2QkFBSzs0QkFDOUMsT0FBTztnQ0FDTCxHQUFHMkYsUUFBUTtnQ0FDWC9ILE9BQU82SjtnQ0FDUDFCLFdBQVcwQixhQUFhN0gsTUFBTTtnQ0FDOUJtRCxPQUFPMEUsRUFBQUEsaUJBQUFBLFlBQVksQ0FBQyxFQUFFLGNBQWZBLHFDQUFBQSxlQUFpQjFFLEtBQUssS0FBSTRDLFNBQVM1QyxLQUFLOzRCQUNqRDt3QkFDRjtvQkFDRjtvQkFDQSxPQUFPNEM7Z0JBQ1Q7UUFFSixFQUFFLE9BQU9oRixPQUFPO1lBQ2RwQixRQUFRb0IsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDbEQ7SUFDRjtJQUVBLDRCQUE0QjtJQUM1QixNQUFNK0cseUJBQXlCLE9BQU9ULFlBQW9CaEI7UUFDeEQsTUFBTTdHLFNBQVNKO1FBQ2YsSUFBSSxDQUFDSSxRQUFRO1FBRWIsSUFBSTtZQUNGLE1BQU0sRUFBRXVCLEtBQUssRUFBRSxHQUFHLE1BQU10RCxtREFBUUEsQ0FDN0JrRCxJQUFJLENBQUMsa0JBQ0w4RixNQUFNLEdBQ05yRixFQUFFLENBQUMsZUFBZW1GLFNBQVNjLGFBQzNCakcsRUFBRSxDQUFDLFdBQVdtRixTQUFTRjtZQUUxQixJQUFJdEYsT0FBTyxNQUFNQTtZQUVqQnhDLGFBQWFxSSxDQUFBQSxPQUNYQSxLQUFLL0csR0FBRyxDQUFDa0csQ0FBQUE7b0JBQ1AsSUFBSUEsU0FBUzdDLEVBQUUsS0FBS21FLFlBQVk7NEJBTXJCUTt3QkFMVCxNQUFNQSxlQUFlOUIsU0FBUy9ILEtBQUssQ0FBQzBELE1BQU0sQ0FBQ3RCLENBQUFBLE9BQVFBLEtBQUs4QyxFQUFFLEtBQUttRDt3QkFDL0QsT0FBTzs0QkFDTCxHQUFHTixRQUFROzRCQUNYL0gsT0FBTzZKOzRCQUNQMUIsV0FBVzBCLGFBQWE3SCxNQUFNOzRCQUM5Qm1ELE9BQU8wRSxFQUFBQSxpQkFBQUEsWUFBWSxDQUFDLEVBQUUsY0FBZkEscUNBQUFBLGVBQWlCMUUsS0FBSyxLQUFJO3dCQUNuQztvQkFDRjtvQkFDQSxPQUFPNEM7Z0JBQ1Q7UUFFSixFQUFFLE9BQU9oRixPQUFPO1lBQ2RwQixRQUFRb0IsS0FBSyxDQUFDLHNDQUFzQ0E7UUFDdEQ7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNZ0gsaUJBQWlCLE9BQU8xQjtRQUM1QixNQUFNN0csU0FBU0o7UUFDZixJQUFJLENBQUNJLFFBQVE7UUFFYixJQUFJO1lBQ0YsTUFBTSxFQUFFdUIsS0FBSyxFQUFFLEdBQUcsTUFBTXRELG1EQUFRQSxDQUM3QmtELElBQUksQ0FBQyxTQUNMNkcsTUFBTSxDQUFDO2dCQUFFN0MsbUJBQW1CNEIsU0FBU0Y7WUFBUSxHQUM3Q2pGLEVBQUUsQ0FBQyxNQUFNNUI7WUFFWixJQUFJdUIsT0FBTyxNQUFNQTtRQUNuQixFQUFFLE9BQU9BLE9BQU87WUFDZHBCLFFBQVFvQixLQUFLLENBQUMsNkJBQTZCQTtRQUM3QztJQUNGO0lBRUEscURBQXFEO0lBQ3JELE1BQU1pSCx5QkFBeUIsT0FBTzNCO1FBQ3BDLE1BQU03RyxTQUFTSjtRQUNmLElBQUksQ0FBQ0ksUUFBUTtRQUViLGdFQUFnRTtRQUNoRSxJQUFJTCxlQUFlMEIsT0FBTyxJQUFJNUIsc0JBQXNCO1lBQ2xELE1BQU1nSixVQUFVLElBQUlDO1lBQ3BCLE1BQU1DLGtCQUFrQixDQUFDRixRQUFRRyxPQUFPLEtBQUtuSixxQkFBcUJtSixPQUFPLEVBQUMsSUFBTSxRQUFPLEVBQUM7WUFFeEYsSUFBSUQsa0JBQWtCLEtBQUs7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTUUsVUFBVWpHLEtBQUtrRyxLQUFLLENBQUNILGtCQUFrQixPQUFPO29CQUNwRCxNQUFNLEVBQUVwSCxLQUFLLEVBQUUsR0FBRyxNQUFNdEQsbURBQVFBLENBQUNpSixHQUFHLENBQUMsMEJBQTBCO3dCQUM3RDZCLFdBQVcvSTt3QkFDWG1ILGNBQWNKLFNBQVNwSCxlQUFlMEIsT0FBTzt3QkFDN0N3SCxTQUFTQTtvQkFDWDtvQkFFQSxJQUFJdEgsT0FBTzt3QkFDVHBCLFFBQVFvQixLQUFLLENBQUMsbUNBQW1DQTtvQkFDbkQsT0FBTzt3QkFDTHBCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBZ0RULE9BQXpCa0osU0FBUSxtQkFBd0MsT0FBdkJsSixlQUFlMEIsT0FBTztvQkFDcEY7Z0JBQ0YsRUFBRSxPQUFPRSxPQUFPO29CQUNkcEIsUUFBUW9CLEtBQUssQ0FBQywwQ0FBMENBO2dCQUMxRDtZQUNGO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUI1QixlQUFlMEIsT0FBTyxHQUFHd0Y7UUFDekJuSCx3QkFBd0IsSUFBSWdKO1FBRTVCLG1DQUFtQztRQUNuQyxNQUFNSCxlQUFlMUI7UUFDckIsSUFBSTtZQUNGLE1BQU01SSxtREFBUUEsQ0FBQ2lKLEdBQUcsQ0FBQyx3QkFBd0I7Z0JBQUVDLGNBQWNKLFNBQVNGO1lBQVE7UUFDOUUsRUFBRSxPQUFPdEYsT0FBTztZQUNkcEIsUUFBUW9CLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2xEO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsTUFBTXlILDBCQUEwQjtRQUM5QixNQUFNaEosU0FBU0o7UUFDZixJQUFJRCxlQUFlMEIsT0FBTyxJQUFJNUIsd0JBQXdCTyxRQUFRO1lBQzVELE1BQU15SSxVQUFVLElBQUlDO1lBQ3BCLE1BQU1DLGtCQUFrQixDQUFDRixRQUFRRyxPQUFPLEtBQUtuSixxQkFBcUJtSixPQUFPLEVBQUMsSUFBTSxRQUFPLEVBQUM7WUFFeEYsSUFBSUQsa0JBQWtCLEtBQUs7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTUUsVUFBVWpHLEtBQUtrRyxLQUFLLENBQUNILGtCQUFrQixPQUFPO29CQUNwRCxNQUFNLEVBQUVwSCxLQUFLLEVBQUUsR0FBRyxNQUFNdEQsbURBQVFBLENBQUNpSixHQUFHLENBQUMsMEJBQTBCO3dCQUM3RDZCLFdBQVcvSTt3QkFDWG1ILGNBQWNKLFNBQVNwSCxlQUFlMEIsT0FBTzt3QkFDN0N3SCxTQUFTQTtvQkFDWDtvQkFFQSxJQUFJdEgsT0FBTzt3QkFDVHBCLFFBQVFvQixLQUFLLENBQUMsMkNBQTJDQTtvQkFDM0QsT0FBTzt3QkFDTHBCLFFBQVFDLEdBQUcsQ0FBQywwQ0FBeURULE9BQXpCa0osU0FBUSxtQkFBd0MsT0FBdkJsSixlQUFlMEIsT0FBTztvQkFDN0Y7Z0JBQ0YsRUFBRSxPQUFPRSxPQUFPO29CQUNkcEIsUUFBUW9CLEtBQUssQ0FBQyx1Q0FBdUNBO2dCQUN2RDtZQUNGO1FBQ0Y7UUFFQTVCLGVBQWUwQixPQUFPLEdBQUc7UUFDekIzQix3QkFBd0I7SUFDMUI7SUFFQSx3Q0FBd0M7SUFDeEN4QixnREFBU0EsQ0FBQztRQUNSLE1BQU04QixTQUFTSjtRQUNmLElBQUlJLFFBQVE7WUFDVlIsV0FBVztZQUNYLE1BQU15SixXQUFXO2dCQUNmLElBQUk7b0JBQ0YsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO3dCQUFDdkY7d0JBQWN3Qzt3QkFBa0JIO3FCQUFzQjtnQkFDM0UsRUFBRSxPQUFPMUUsT0FBTztvQkFDZHBCLFFBQVFvQixLQUFLLENBQUMsdUJBQXVCQTtnQkFDdkMsU0FBVTtvQkFDUi9CLFdBQVc7Z0JBQ2I7WUFDRjtZQUNBeUo7UUFDRixPQUFPO1lBQ0wsMEJBQTBCO1lBQzFCM0ssV0FBVytDLE9BQU8sR0FBRztZQUNyQjlDLGdCQUFnQjhDLE9BQU8sR0FBRztZQUMxQjVDLFNBQVMsRUFBRTtZQUNYRSxxQkFBcUIsRUFBRTtZQUN2QkUsaUJBQWlCLEVBQUU7WUFDbkJFLGFBQWEsRUFBRTtZQUNmRSxjQUFjLElBQUlDO1lBQ2xCSSx1QkFBdUIsRUFBRTtZQUN6QkYsa0JBQWtCO1lBQ2xCSSxXQUFXO1FBQ2I7SUFDRixHQUFHO1FBQUNJO0tBQVksRUFBRSw2Q0FBNkM7O0lBRS9ELHlFQUF5RTtJQUN6RTFCLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTWtMLHNCQUFzQixDQUFDQztZQUMzQixJQUFJQSxFQUFFQyxHQUFHLEtBQUssV0FBVztnQkFDdkIsTUFBTXRKLFNBQVNxSixFQUFFRSxRQUFRO2dCQUN6QixJQUFJdkosUUFBUTtvQkFDVlIsV0FBVztvQkFDWDBKLFFBQVFDLEdBQUcsQ0FBQzt3QkFBQ3ZGO3dCQUFjd0M7d0JBQWtCSDtxQkFBc0IsRUFDaEV1RCxPQUFPLENBQUMsSUFBTWhLLFdBQVc7Z0JBQzlCLE9BQU87b0JBQ0wsa0JBQWtCO29CQUNsQmxCLFdBQVcrQyxPQUFPLEdBQUc7b0JBQ3JCOUMsZ0JBQWdCOEMsT0FBTyxHQUFHO29CQUMxQjVDLFNBQVMsRUFBRTtvQkFDWEUscUJBQXFCLEVBQUU7b0JBQ3ZCRSxpQkFBaUIsRUFBRTtvQkFDbkJFLGFBQWEsRUFBRTtvQkFDZkUsY0FBYyxJQUFJQztvQkFDbEJJLHVCQUF1QixFQUFFO29CQUN6QkYsa0JBQWtCO29CQUNsQkksV0FBVztnQkFDYjtZQUNGO1FBQ0Y7UUFFQWlLLE9BQU9DLGdCQUFnQixDQUFDLFdBQVdOO1FBQ25DLE9BQU8sSUFBTUssT0FBT0UsbUJBQW1CLENBQUMsV0FBV1A7SUFDckQsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMNUs7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUUsWUFBWVIsTUFBTTBELE1BQU0sQ0FBQ3RCLENBQUFBLE9BQVFBLEtBQUs0QyxPQUFPO1FBQzdDbkU7UUFDQUY7UUFDQUk7UUFDQXFIO1FBQ0FjO1FBQ0FFO1FBQ0FFO1FBQ0FHO1FBQ0FLO1FBQ0FFO1FBQ0FRO1FBQ0FZLGFBQWE7WUFDWCxNQUFNNUosU0FBU0o7WUFDZixJQUFJSSxRQUFRO2dCQUNWUixXQUFXO2dCQUNYMEosUUFBUUMsR0FBRyxDQUFDO29CQUFDdkY7b0JBQWN3QztvQkFBa0JIO2lCQUFzQixFQUNoRXVELE9BQU8sQ0FBQyxJQUFNaEssV0FBVztZQUM5QjtRQUNGO1FBQ0E4RjtRQUNBdkY7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cz9hYmZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFiYXNlU29uZywgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBQbGF5bGlzdCwgU29uZyB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VwYWJhc2VEYXRhKCkge1xuICAvLyBDYWNoZXMgZm9yIHNvbmdzIGFuZCBsaWtlZCBzb25ncyB0byBhdm9pZCByZXBlYXRlZCBjbG91ZCBmZXRjaGVzXG4gIGNvbnN0IHNvbmdzQ2FjaGUgPSB1c2VSZWY8YW55W10gfCBudWxsPihudWxsKTtcbiAgY29uc3QgbGlrZWRTb25nc0NhY2hlID0gdXNlUmVmPFNldDxudW1iZXI+IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzb25ncywgc2V0U29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgLy8gUGVyc29uYWxpemVkIHNvbmdzIHN0YXRlIChzbWFydCBzb3J0ZWQsIGZpbHRlcmVkLCBhbmQgaGlzdG9yeS1leGNsdWRlZClcbiAgY29uc3QgW3BlcnNvbmFsaXplZFNvbmdzLCBzZXRQZXJzb25hbGl6ZWRTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICAvLyBUcmVuZGluZyBzb25ncyBzdGF0ZSAodG9wIDE1IGJ5IHZpZXdzK2xpa2VzKVxuICBjb25zdCBbdHJlbmRpbmdTb25ncywgc2V0VHJlbmRpbmdTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICBjb25zdCBbcGxheWxpc3RzLCBzZXRQbGF5bGlzdHNdID0gdXNlU3RhdGU8UGxheWxpc3RbXT4oW10pXG4gIGNvbnN0IFtsaWtlZFNvbmdzLCBzZXRMaWtlZFNvbmdzXSA9IHVzZVN0YXRlPFNldDxudW1iZXI+PihuZXcgU2V0KCkpXG4gIGNvbnN0IFtsYXN0UGxheWVkU29uZywgc2V0TGFzdFBsYXllZFNvbmddID0gdXNlU3RhdGU8U29uZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtyZWNlbnRseVBsYXllZFNvbmdzLCBzZXRSZWNlbnRseVBsYXllZFNvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbY3VycmVudFNvbmdTdGFydFRpbWUsIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKVxuICBjb25zdCBjdXJyZW50U29uZ1JlZiA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKVxuXG4gIC8vIEdldCB1c2VyIElEIGZyb20gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IGdldFVzZXJJZCA9ICgpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfaWQnKVxuICB9XG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgYWN0dWFsIGxpc3RlbmluZyBwcmVmZXJlbmNlc1xuICBjb25zdCBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIGxpc3RlbmVkU29uZ3NJbkJhdGNoOiBTb25nW10sIFxuICAgIGV4Y2x1ZGVTb25nczogU2V0PHN0cmluZz5cbiAgKTogUHJvbWlzZTxTb25nW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfp6AgRmV0Y2hpbmcgc21hcnQgcGVyc29uYWxpemVkIHNvbmdzIGJhc2VkIG9uIGxpc3RlbmluZyBiZWhhdmlvcicpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgU29uZ3MgdXNlciBhY3R1YWxseSBsaXN0ZW5lZCB0bzonLCBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5tYXAocyA9PiBzLm5hbWUpKTtcbiAgICAgIFxuICAgICAgaWYgKGxpc3RlbmVkU29uZ3NJbkJhdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIGxpc3RlbmVkIHNvbmdzIGluIGJhdGNoLCBmYWxsaW5nIGJhY2sgdG8gcmVndWxhciBwZXJzb25hbGl6YXRpb24nKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IHRhZ3MgYW5kIGFydGlzdHMgZnJvbSBsaXN0ZW5lZCBzb25nc1xuICAgICAgY29uc3QgcHJlZmVycmVkVGFncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgY29uc3QgcHJlZmVycmVkQXJ0aXN0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgXG4gICAgICBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5mb3JFYWNoKHNvbmcgPT4ge1xuICAgICAgICBzb25nLnRhZ3M/LmZvckVhY2godGFnID0+IHByZWZlcnJlZFRhZ3MuYWRkKHRhZy50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIHByZWZlcnJlZEFydGlzdHMuYWRkKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn4+377iPIFByZWZlcnJlZCB0YWdzOicsIEFycmF5LmZyb20ocHJlZmVycmVkVGFncykpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjqQgUHJlZmVycmVkIGFydGlzdHM6JywgQXJyYXkuZnJvbShwcmVmZXJyZWRBcnRpc3RzKSk7XG5cbiAgICAgIC8vIFVzZSBjYWNoZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmZXRjaCBhbmQgY2FjaGVcbiAgICAgIGxldCBzb25nc0RhdGEgPSBzb25nc0NhY2hlLmN1cnJlbnQ7XG4gICAgICBpZiAoIXNvbmdzRGF0YSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc29uZ3MgZm9yIHNtYXJ0IHBlcnNvbmFsaXphdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHNvbmdzIGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHNvbmdzRGF0YSA9IGRhdGE7XG4gICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCF1c2VyTGlrZWRTb25ncykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzIS5hZGQoaXRlbS5zb25nX2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSB1c2VyTGlrZWRTb25ncztcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIGFuZCBzY29yZSBzb25ncyBiYXNlZCBvbiBsaXN0ZW5pbmcgcHJlZmVyZW5jZXMgYW5kIGxhbmd1YWdlXG4gICAgICAvLyBVc2UgdGhlIGxhbmd1YWdlIG9mIHRoZSBmaXJzdCBsaXN0ZW5lZCBzb25nIGFzIHRoZSBmaWx0ZXJcbiAgICAgIGNvbnN0IGxhbmd1YWdlRmlsdGVyID0gbGlzdGVuZWRTb25nc0luQmF0Y2hbMF0/Lmxhbmd1YWdlO1xuICAgICAgY29uc3QgYXZhaWxhYmxlU29uZ3MgPSBzb25nc0RhdGEuZmlsdGVyKChzb25nKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgIWV4Y2x1ZGVTb25ncy5oYXMoc29uZy5maWxlX2lkLnRvU3RyaW5nKCkpICYmXG4gICAgICAgICAgc29uZy5sYW5ndWFnZSA9PT0gbGFuZ3VhZ2VGaWx0ZXJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+OtSBBdmFpbGFibGUgc29uZ3MgZm9yIHNtYXJ0IHJlY29tbWVuZGF0aW9ucyAobGFuZ3VhZ2U6ICR7bGFuZ3VhZ2VGaWx0ZXJ9KTogJHthdmFpbGFibGVTb25ncy5sZW5ndGh9YCk7XG5cbiAgICAgIGlmIChhdmFpbGFibGVTb25ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gYXZhaWxhYmxlIHNvbmdzIGFmdGVyIGZpbHRlcmluZycpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIC8vIFNjb3JlIHNvbmdzIGJhc2VkIG9uIHVzZXIncyBsaXN0ZW5pbmcgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gYXZhaWxhYmxlU29uZ3MubWFwKChzb25nKSA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgICAgLy8gSGlnaCBwcmlvcml0eTogVGFnIG1hdGNoaW5nIHdpdGggbGlzdGVuZWQgc29uZ3NcbiAgICAgICAgY29uc3Qgc29uZ1RhZ3MgPSBzb25nLnRhZ3M/Lm1hcCgodGFnOiBzdHJpbmcpID0+IHRhZy50b0xvd2VyQ2FzZSgpKSB8fCBbXTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdUYWdzID0gc29uZ1RhZ3MuZmlsdGVyKCh0YWc6IHN0cmluZykgPT4gcHJlZmVycmVkVGFncy5oYXModGFnKSk7XG4gICAgICAgIHNjb3JlICs9IG1hdGNoaW5nVGFncy5sZW5ndGggKiAyNTsgLy8gSGlnaGVyIHdlaWdodCBmb3IgdGFnIG1hdGNoaW5nXG5cbiAgICAgICAgLy8gSGlnaCBwcmlvcml0eTogQXJ0aXN0IG1hdGNoaW5nIHdpdGggbGlzdGVuZWQgc29uZ3NcbiAgICAgICAgaWYgKHByZWZlcnJlZEFydGlzdHMuaGFzKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMzA7IC8vIEhpZ2hlciB3ZWlnaHQgZm9yIGFydGlzdCBtYXRjaGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVkaXVtIHByaW9yaXR5OiBTYW1lIGxhbmd1YWdlIGFzIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGNvbnN0IGxpc3RlbmVkTGFuZ3VhZ2VzID0gbGlzdGVuZWRTb25nc0luQmF0Y2gubWFwKHMgPT4gcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmIChsaXN0ZW5lZExhbmd1YWdlcy5pbmNsdWRlcyhzb25nLmxhbmd1YWdlKSkge1xuICAgICAgICAgIHNjb3JlICs9IDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG93ZXIgcHJpb3JpdHk6IEdlbmVyYWwgcG9wdWxhcml0eVxuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcubGlrZXMgfHwgMCkpICogMjtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLnZpZXdzIHx8IDApKSAqIDE7XG5cbiAgICAgICAgLy8gQm9udXMgZm9yIGxpa2VkIHNvbmdzXG4gICAgICAgIGlmICh1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSkge1xuICAgICAgICAgIHNjb3JlICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHNtYWxsIHJhbmRvbW5lc3MgdG8gYXZvaWQgcmVwZXRpdGlvblxuICAgICAgICBzY29yZSArPSBNYXRoLnJhbmRvbSgpICogMjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLCBcbiAgICAgICAgICBzY29yZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNvcnQgYnkgc2NvcmUgYW5kIHJldHVybiB0b3AgcmVjb21tZW5kYXRpb25zXG4gICAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSBzY29yZWRTb25nc1xuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpXG4gICAgICAgIC5zbGljZSgwLCAxNSkgLy8gR2V0IG1vcmUgc29uZ3MgZm9yIHZhcmlldHlcbiAgICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5zb25nKTtcblxuICAgICAgY29uc29sZS5sb2coJ/Cfp6AgU21hcnQgcmVjb21tZW5kYXRpb25zIGJhc2VkIG9uIGxpc3RlbmluZyBiZWhhdmlvcjonLCBcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnNsaWNlKDAsIDUpLm1hcChzID0+IGAke3MubmFtZX0gYnkgJHtzLmFydGlzdH1gKSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZWNvbW1lbmRhdGlvbnM7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIGdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvLyBDb252ZXJ0IGRhdGFiYXNlIHNvbmcgdG8gVUkgc29uZyBmb3JtYXRcbiAgY29uc3QgY29udmVydERhdGFiYXNlU29uZyA9IChkYlNvbmc6IERhdGFiYXNlU29uZywgaXNMaWtlZDogYm9vbGVhbiA9IGZhbHNlKTogU29uZyA9PiAoe1xuICAgIGZpbGVfaWQ6IGRiU29uZy5maWxlX2lkLFxuICAgIGltZ19pZDogZGJTb25nLmltZ19pZCxcbiAgICBuYW1lOiBkYlNvbmcubmFtZSxcbiAgICBhcnRpc3Q6IGRiU29uZy5hcnRpc3QsXG4gICAgbGFuZ3VhZ2U6IGRiU29uZy5sYW5ndWFnZSxcbiAgICB0YWdzOiBkYlNvbmcudGFncyxcbiAgICB2aWV3czogZGJTb25nLnZpZXdzLFxuICAgIGxpa2VzOiBkYlNvbmcubGlrZXMsXG4gICAgaWQ6IGRiU29uZy5maWxlX2lkLnRvU3RyaW5nKCksXG4gICAgaW1hZ2U6IGBodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8ke2RiU29uZy5pbWdfaWR9L3BleGVscy1waG90by0ke2RiU29uZy5pbWdfaWR9LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMGAsXG4gICAgaXNMaWtlZFxuICB9KVxuXG4gIC8vIEZldGNoIGFsbCBzb25nc1xuICBjb25zdCBmZXRjaFNvbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIHNldFNvbmdzKFtdKVxuICAgICAgc2V0UGVyc29uYWxpemVkU29uZ3MoW10pXG4gICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgYWxsIHNvbmdzIGZyb20gc3VwYWJhc2UuLi4nKTtcbiAgICAgIGNvbnN0IHsgZGF0YTogc29uZ3NEYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcigndmlld3MnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHNvbmdzOicsIHNvbmdzRGF0YT8ubGVuZ3RoKTtcblxuICAgICAgLy8gRmV0Y2ggbGlrZWQgc29uZ3NcbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQ8bnVtYmVyPigpXG4gICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0KGxpa2VkRGF0YS5tYXAoaXRlbSA9PiBpdGVtLnNvbmdfaWQpKVxuICAgICAgICBzZXRMaWtlZFNvbmdzKHVzZXJMaWtlZFNvbmdzKVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB1c2VyIGhpc3RvcnkgKGZvciBtaW51dGVzX2xpc3RlbmVkKVxuICAgICAgY29uc3QgeyBkYXRhOiBoaXN0b3J5RGF0YSwgZXJyb3I6IGhpc3RvcnlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkLCBtaW51dGVzX2xpc3RlbmVkLCBzb25ncygqKScpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLm9yZGVyKCdtaW51dGVzX2xpc3RlbmVkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB0aHJvdyBoaXN0b3J5RXJyb3JcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHVzZXIgaGlzdG9yeTonLCBoaXN0b3J5RGF0YT8ubGVuZ3RoKTtcblxuICAgICAgLy8gR2V0IHRvcCAxNSBtb3N0IGxpc3RlbmVkIHNvbmdzIGZyb20gaGlzdG9yeVxuICAgICAgY29uc3QgdG9wSGlzdG9yeSA9IChoaXN0b3J5RGF0YSB8fCBbXSkuc2xpY2UoMCwgMTUpLmZpbHRlcihoID0+IGguc29uZ3MpXG4gICAgICAvLyBDb2xsZWN0IHRhZ3MgYW5kIGFydGlzdHMgZnJvbSB0b3AgMTVcbiAgICAgIGNvbnN0IHRhZ0NvdW50OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge31cbiAgICAgIGNvbnN0IGFydGlzdENvdW50OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge31cbiAgICAgIHRvcEhpc3RvcnkuZm9yRWFjaChoID0+IHtcbiAgICAgICAgLy8gaC5zb25ncyBtYXkgYmUgYW4gYXJyYXkgb3Igb2JqZWN0LCB1c2UgZmlyc3QgaWYgYXJyYXlcbiAgICAgICAgY29uc3Qgc29uZ09iaiA9IEFycmF5LmlzQXJyYXkoaC5zb25ncykgPyBoLnNvbmdzWzBdIDogaC5zb25ncztcbiAgICAgICAgKHNvbmdPYmo/LnRhZ3MgfHwgW10pLmZvckVhY2goKHRhZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHRhZ0NvdW50W3RdID0gKHRhZ0NvdW50W3RdIHx8IDApICsgMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzb25nT2JqPy5hcnRpc3QpIHtcbiAgICAgICAgICBjb25zdCBhID0gc29uZ09iai5hcnRpc3QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBhcnRpc3RDb3VudFthXSA9IChhcnRpc3RDb3VudFthXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gRmluZCBtb3N0IGNvbW1vbiB0YWdzIGFuZCBhcnRpc3RzXG4gICAgICBjb25zdCBjb21tb25UYWdzID0gT2JqZWN0LmVudHJpZXModGFnQ291bnQpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcbiAgICAgICAgLnNsaWNlKDAsIDUpXG4gICAgICAgIC5tYXAoKFt0YWddKSA9PiB0YWcpO1xuICAgICAgY29uc3QgY29tbW9uQXJ0aXN0cyA9IE9iamVjdC5lbnRyaWVzKGFydGlzdENvdW50KVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgIC5zbGljZSgwLCA1KVxuICAgICAgICAubWFwKChbYXJ0aXN0XSkgPT4gYXJ0aXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBzaW1pbGFyIHRhZ3M6JywgY29tbW9uVGFncyk7XG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgc2ltaWxhciBhcnRpc3RzOicsIGNvbW1vbkFydGlzdHMpO1xuXG4gICAgICAvLyBTb25ncyBpbiBoaXN0b3J5ICh0byBleGNsdWRlIGZvciBzbWFydCBzb3J0KVxuICAgICAgY29uc3QgaGlzdG9yeVNvbmdJZHMgPSBuZXcgU2V0KChoaXN0b3J5RGF0YSB8fCBbXSkubWFwKGggPT4gaC5zb25nX2lkPy50b1N0cmluZygpKSk7XG5cbiAgICAgIC8vIENvbnZlcnQgYWxsIHNvbmdzXG4gICAgICBjb25zdCBjb252ZXJ0ZWRTb25ncyA9IHNvbmdzRGF0YT8ubWFwKHNvbmcgPT5cbiAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhzb25nLCB1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSlcbiAgICAgICkgfHwgW107XG5cbiAgICAgIHNldFNvbmdzKGNvbnZlcnRlZFNvbmdzKTsgLy8gc29uZ3MgaXMgbm93IGFsbCBzb25ncywgbm90IHBlcnNvbmFsaXplZFxuXG4gICAgICAvLyBGaWx0ZXIgb3V0IHNvbmdzIGluIGhpc3RvcnkgZm9yIHBlcnNvbmFsaXplZCBzb3J0XG4gICAgICBjb25zdCBmaWx0ZXJlZFNvbmdzID0gY29udmVydGVkU29uZ3MuZmlsdGVyKHNvbmcgPT4gIWhpc3RvcnlTb25nSWRzLmhhcyhzb25nLmlkKSk7XG5cbiAgICAgIC8vIFNjb3JlIHNvbmdzIGJ5IHRhZy9hcnRpc3QgbWF0Y2hcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gZmlsdGVyZWRTb25ncy5tYXAoc29uZyA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIC8vIFRhZyBtYXRjaFxuICAgICAgICBjb25zdCBzb25nVGFncyA9IChzb25nLnRhZ3MgfHwgW10pLm1hcCgodDogc3RyaW5nKSA9PiB0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzY29yZSArPSBzb25nVGFncy5maWx0ZXIodCA9PiBjb21tb25UYWdzLmluY2x1ZGVzKHQpKS5sZW5ndGggKiAxMDtcbiAgICAgICAgLy8gQXJ0aXN0IG1hdGNoXG4gICAgICAgIGlmIChzb25nLmFydGlzdCAmJiBjb21tb25BcnRpc3RzLmluY2x1ZGVzKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMjA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhcml0eVxuICAgICAgICBzY29yZSArPSAoc29uZy52aWV3cyB8fCAwKSArIChzb25nLmxpa2VzIHx8IDApO1xuICAgICAgICByZXR1cm4geyBzb25nLCBzY29yZSB9O1xuICAgICAgfSk7XG4gICAgICAvLyBTb3J0IGJ5IHNjb3JlIGRlc2NlbmRpbmdcbiAgICAgIGNvbnN0IHBlcnNvbmFsaXplZFNvcnRlZCA9IHNjb3JlZFNvbmdzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKS5tYXAocyA9PiBzLnNvbmcpO1xuXG4gICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhwZXJzb25hbGl6ZWRTb3J0ZWQpO1xuXG4gICAgICAvLyBUcmVuZGluZzogdG9wIDE1IGJ5IHZpZXdzK2xpa2VzIChmcm9tIGFsbCBzb25ncywgaW5jbHVkaW5nIGhpc3RvcnkpXG4gICAgICBjb25zdCB0cmVuZGluZyA9IFsuLi5jb252ZXJ0ZWRTb25nc11cbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IChiLnZpZXdzICsgYi5saWtlcykgLSAoYS52aWV3cyArIGEubGlrZXMpKVxuICAgICAgICAuc2xpY2UoMCwgMTUpO1xuICAgICAgc2V0VHJlbmRpbmdTb25ncyh0cmVuZGluZyk7XG4gICAgICBjb25zb2xlLmxvZygnVHJlbmRpbmcgc29uZ3M6JywgdHJlbmRpbmcubWFwKHMgPT4gYCR7cy5uYW1lfSAoJHtzLnZpZXdzfSB2aWV3cywgJHtzLmxpa2VzfSBsaWtlcylgKSk7XG5cbiAgICAgIC8vIFNldCBsYXN0IHBsYXllZCBzb25nIGFzIGJlZm9yZVxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBpZiAodXNlckRhdGE/Lmxhc3Rfc29uZ19maWxlX2lkKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTb25nID0gY29udmVydGVkU29uZ3MuZmluZChzb25nID0+IHNvbmcuZmlsZV9pZCA9PT0gdXNlckRhdGEubGFzdF9zb25nX2ZpbGVfaWQpXG4gICAgICAgIGlmIChsYXN0U29uZykge1xuICAgICAgICAgIHNldExhc3RQbGF5ZWRTb25nKGxhc3RTb25nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNvbmdzOicsIGVycm9yKVxuICAgICAgc2V0U29uZ3MoW10pXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgZmlsdGVyaW5nXG4gIGNvbnN0IGdldFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBjdXJyZW50U29uZzogU29uZywgbGlzdGVuZWRTb25ncz86IFNldDxzdHJpbmc+KTogUHJvbWlzZTxTb25nW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgRmV0Y2hpbmcgcGVyc29uYWxpemVkIHNvbmdzIGZvcjonLCBjdXJyZW50U29uZy5uYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IExpc3RlbmVkIHNvbmdzIGNvdW50OicsIGxpc3RlbmVkU29uZ3M/LnNpemUgfHwgMCk7XG4gICAgICBcbiAgICAgIC8vIDEuIEZldGNoIGFsbCBzb25ncyBmcm9tIGNhY2hlIG9yIGNsb3VkXG4gICAgICBsZXQgc29uZ3NEYXRhID0gc29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCFzb25nc0RhdGEpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJyonKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHNvbmdzIGZvciBwZXJzb25hbGl6YXRpb246JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBzb25ncyBmb3VuZCBpbiBkYXRhYmFzZScpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBzb25nc0RhdGEgPSBkYXRhO1xuICAgICAgICBzb25nc0NhY2hlLmN1cnJlbnQgPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBGZXRjaCB1c2VyJ3MgbGlzdGVuaW5nIGhpc3RvcnkgKG5vdCBjYWNoZWQsIGFzIGl0IG1heSBjaGFuZ2UgZnJlcXVlbnRseSlcbiAgICAgIGNvbnN0IHsgZGF0YTogaGlzdG9yeURhdGEsIGVycm9yOiBoaXN0b3J5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdoaXN0b3J5JylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCwgbWludXRlc19saXN0ZW5lZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBoaXN0b3J5OicsIGhpc3RvcnlFcnJvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBoaXN0b3J5TWFwID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcbiAgICAgIGlmIChoaXN0b3J5RGF0YSkge1xuICAgICAgICBoaXN0b3J5RGF0YS5mb3JFYWNoKGggPT4gaGlzdG9yeU1hcC5zZXQoaC5zb25nX2lkLCBoLm1pbnV0ZXNfbGlzdGVuZWQgfHwgMCkpO1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBHZXQgdXNlcidzIGxpa2VkIHNvbmdzIGZyb20gY2FjaGUgb3IgY2xvdWRcbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCF1c2VyTGlrZWRTb25ncykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzIS5hZGQoaXRlbS5zb25nX2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSB1c2VyTGlrZWRTb25ncztcbiAgICAgIH1cblxuICAgICAgLy8gNC4gRmlsdGVyIGFuZCBzY29yZSBzb25ncyAoYWRkIGxhbmd1YWdlIGZpbHRlcilcbiAgICAgIGNvbnN0IGxhbmd1YWdlRmlsdGVyID0gY3VycmVudFNvbmcubGFuZ3VhZ2U7XG4gICAgICBjb25zdCBhdmFpbGFibGVTb25ncyA9IHNvbmdzRGF0YS5maWx0ZXIoKHNvbmcpID0+IHtcbiAgICAgICAgLy8gRXhjbHVkZSBjdXJyZW50IHNvbmdcbiAgICAgICAgaWYgKHNvbmcuZmlsZV9pZCA9PT0gY3VycmVudFNvbmcuZmlsZV9pZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGNsdWRlIGxpc3RlbmVkIHNvbmdzIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChsaXN0ZW5lZFNvbmdzICYmIGxpc3RlbmVkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZC50b1N0cmluZygpKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEV4Y2x1ZGluZyBsaXN0ZW5lZCBzb25nOiAke3NvbmcubmFtZX0gYnkgJHtzb25nLmFydGlzdH1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBpbmNsdWRlIHNvbmdzIHdpdGggdGhlIHNhbWUgbGFuZ3VhZ2UgYXMgY3VycmVudCBzb25nXG4gICAgICAgIGlmIChzb25nLmxhbmd1YWdlICE9PSBsYW5ndWFnZUZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+OtSBBdmFpbGFibGUgc29uZ3MgYWZ0ZXIgZmlsdGVyaW5nIChsYW5ndWFnZTogJHtsYW5ndWFnZUZpbHRlcn0pOiAke2F2YWlsYWJsZVNvbmdzLmxlbmd0aH1gKTtcblxuICAgICAgaWYgKGF2YWlsYWJsZVNvbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBhdmFpbGFibGUgc29uZ3MgYWZ0ZXIgZmlsdGVyaW5nJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gNS4gU2NvcmUgYW5kIHNvcnQgc29uZ3NcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gYXZhaWxhYmxlU29uZ3MubWFwKChzb25nKSA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgICAgLy8gVGFnIG1hdGNoaW5nIChoaWdoZXN0IHByaW9yaXR5KVxuICAgICAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBzb25nLnRhZ3M/LmZpbHRlcigodGFnOiBzdHJpbmcpID0+XG4gICAgICAgICAgY3VycmVudFNvbmcudGFncz8uaW5jbHVkZXModGFnKVxuICAgICAgICApIHx8IFtdO1xuICAgICAgICBzY29yZSArPSBtYXRjaGluZ1RhZ3MubGVuZ3RoICogMTU7XG5cbiAgICAgICAgLy8gQXJ0aXN0IG1hdGNoaW5nXG4gICAgICAgIGlmIChzb25nLmFydGlzdCA9PT0gY3VycmVudFNvbmcuYXJ0aXN0KSB7XG4gICAgICAgICAgc2NvcmUgKz0gMjU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYW5ndWFnZSBtYXRjaGluZ1xuICAgICAgICBpZiAoc29uZy5sYW5ndWFnZSA9PT0gY3VycmVudFNvbmcubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzY29yZSArPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpc3RlbmluZyBoaXN0b3J5IGJvb3N0XG4gICAgICAgIGNvbnN0IGxpc3RlbmVkTWludXRlcyA9IGhpc3RvcnlNYXAuZ2V0KHNvbmcuZmlsZV9pZCkgfHwgMDtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5taW4obGlzdGVuZWRNaW51dGVzICogMiwgMjApOyAvLyBDYXAgYXQgMjAgcG9pbnRzXG5cbiAgICAgICAgLy8gUG9wdWxhcml0eSBib29zdCAobGlrZXMgYW5kIHZpZXdzKVxuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcubGlrZXMgfHwgMCkpICogMjtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLnZpZXdzIHx8IDApKSAqIDE7XG5cbiAgICAgICAgLy8gTGlrZWQgc29uZ3MgYm9vc3RcbiAgICAgICAgaWYgKHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjb250cm9sbGVkIHJhbmRvbW5lc3MgdG8gYXZvaWQgcmVwZXRpdGlvblxuICAgICAgICBzY29yZSArPSBNYXRoLnJhbmRvbSgpICogMztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLFxuICAgICAgICAgIHNjb3JlXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gNi4gU29ydCBieSBzY29yZSBhbmQgcmV0dXJuIHRvcCByZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IHNjb3JlZFNvbmdzXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSlcbiAgICAgICAgLnNsaWNlKDAsIDEwKSAvLyBHZXQgbW9yZSBzb25ncyB0byBoYXZlIGEgYnVmZmVyXG4gICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuc29uZyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFBlcnNvbmFsaXplZCByZWNvbW1lbmRhdGlvbnM6JywgcmVjb21tZW5kYXRpb25zLnNsaWNlKDAsIDUpLm1hcChzID0+IGAke3MubmFtZX0gYnkgJHtzLmFydGlzdH1gKSk7XG4gICAgICBjb25zb2xlLmxvZygn8J+OtSBUb3RhbCBhdmFpbGFibGUgc29uZ3M6JywgYXZhaWxhYmxlU29uZ3MubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gZ2V0UGVyc29uYWxpemVkU29uZ3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvLyBGZXRjaCByZWNlbnRseSBwbGF5ZWQgc29uZ3MgYmFzZWQgb24gbGlzdGVuaW5nIGhpc3RvcnlcbiAgY29uc3QgZmV0Y2hSZWNlbnRseVBsYXllZCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB1c2VyJ3MgbGlzdGVuaW5nIGhpc3Rvcnkgc29ydGVkIGJ5IG1pbnV0ZXMgbGlzdGVuZWRcbiAgICAgIGNvbnN0IHsgZGF0YTogaGlzdG9yeURhdGEsIGVycm9yOiBoaXN0b3J5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdoaXN0b3J5JylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgc29uZ19pZCxcbiAgICAgICAgICBtaW51dGVzX2xpc3RlbmVkLFxuICAgICAgICAgIHNvbmdzICgqKVxuICAgICAgICBgKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgIC5vcmRlcignbWludXRlc19saXN0ZW5lZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgICAubGltaXQoOSlcblxuICAgICAgaWYgKGhpc3RvcnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWNlbnRseSBwbGF5ZWQ6JywgaGlzdG9yeUVycm9yKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFoaXN0b3J5RGF0YSB8fCBoaXN0b3J5RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB1c2VyJ3MgbGlrZWQgc29uZ3MgZm9yIHByb3BlciBjb252ZXJzaW9uXG4gICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIFxuICAgICAgY29uc3QgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0PG51bWJlcj4oKVxuICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzLmFkZChpdGVtLnNvbmdfaWQpKVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IHRvIFNvbmcgZm9ybWF0XG4gICAgICBjb25zdCByZWNlbnRTb25ncyA9IGhpc3RvcnlEYXRhXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnNvbmdzKSAvLyBFbnN1cmUgc29uZyBkYXRhIGV4aXN0c1xuICAgICAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IHNvbmdPYmogPSBBcnJheS5pc0FycmF5KGl0ZW0uc29uZ3MpID8gaXRlbS5zb25nc1swXSA6IGl0ZW0uc29uZ3M7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZ09iaiwgdXNlckxpa2VkU29uZ3MuaGFzKGl0ZW0uc29uZ19pZCkpO1xuICAgICAgICB9KTtcblxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhyZWNlbnRTb25ncylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50bHkgcGxheWVkIHNvbmdzOicsIGVycm9yKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyIHBsYXlsaXN0c1xuICBjb25zdCBmZXRjaFBsYXlsaXN0cyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiBwbGF5bGlzdHNEYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGxheWxpc3Rfc29uZ3MgKFxuICAgICAgICAgICAgc29uZ3MgKCopXG4gICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgY29uc3QgY29udmVydGVkUGxheWxpc3RzOiBQbGF5bGlzdFtdID0gcGxheWxpc3RzRGF0YT8ubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgY29uc3QgcGxheWxpc3RTb25ncyA9IHBsYXlsaXN0LnBsYXlsaXN0X3NvbmdzPy5tYXAoKHBzOiBhbnkpID0+IFxuICAgICAgICAgIGNvbnZlcnREYXRhYmFzZVNvbmcocHMuc29uZ3MsIGxpa2VkU29uZ3MuaGFzKHBzLnNvbmdzLmZpbGVfaWQpKVxuICAgICAgICApIHx8IFtdXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogcGxheWxpc3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICBuYW1lOiBwbGF5bGlzdC5uYW1lLFxuICAgICAgICAgIHNvbmdDb3VudDogcGxheWxpc3RTb25ncy5sZW5ndGgsXG4gICAgICAgICAgaW1hZ2U6IHBsYXlsaXN0U29uZ3NbMF0/LmltYWdlIHx8ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xNzYzMDc1L3BleGVscy1waG90by0xNzYzMDc1LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMCcsXG4gICAgICAgICAgc29uZ3M6IHBsYXlsaXN0U29uZ3NcbiAgICAgICAgfVxuICAgICAgfSkgfHwgW11cblxuICAgICAgc2V0UGxheWxpc3RzKGNvbnZlcnRlZFBsYXlsaXN0cylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGxheWxpc3RzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRvZ2dsZSBsaWtlIHNvbmdcbiAgY29uc3QgdG9nZ2xlTGlrZSA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcblxuICAgIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpO1xuICAgIGNvbnN0IGlzQ3VycmVudGx5TGlrZWQgPSBsaWtlZFNvbmdzLmhhcyhzb25nRmlsZUlkKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNDdXJyZW50bHlMaWtlZCkge1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaWtlZF9zb25nc1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgIC5lcSgnc29uZ19pZCcsIHNvbmdGaWxlSWQpO1xuXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAgICAgLy8gRGVjcmVtZW50IGxpa2VzXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLnJwYygnZGVjcmVtZW50X3NvbmdfbGlrZXMnLCB7IHNvbmdfZmlsZV9pZDogc29uZ0ZpbGVJZCB9KTtcblxuICAgICAgICBzZXRMaWtlZFNvbmdzKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBTZXQocHJldik7XG4gICAgICAgICAgbmV3U2V0LmRlbGV0ZShzb25nRmlsZUlkKTtcbiAgICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCB0byBsaWtlZF9zb25nc1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICBzb25nX2lkOiBzb25nRmlsZUlkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGxpa2VzXG4gICAgICAgIGF3YWl0IHN1cGFiYXNlLnJwYygnaW5jcmVtZW50X3NvbmdfbGlrZXMnLCB7IHNvbmdfZmlsZV9pZDogc29uZ0ZpbGVJZCB9KTtcblxuICAgICAgICBzZXRMaWtlZFNvbmdzKHByZXYgPT4gbmV3IFNldChwcmV2KS5hZGQoc29uZ0ZpbGVJZCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGVcbiAgICAgIHNldFNvbmdzKHByZXZTb25ncyA9PlxuICAgICAgICBwcmV2U29uZ3MubWFwKHNvbmcgPT5cbiAgICAgICAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLnNvbmcsXG4gICAgICAgICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgICAgICAgbGlrZXM6IHNvbmcubGlrZXMgKyAoaXNDdXJyZW50bHlMaWtlZCA/IC0xIDogMSksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc29uZ1xuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlXG4gICAgICBzZXRQbGF5bGlzdHMocHJldlBsYXlsaXN0cyA9PlxuICAgICAgICBwcmV2UGxheWxpc3RzLm1hcChwbGF5bGlzdCA9PiAoe1xuICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgIHNvbmdzOiBwbGF5bGlzdC5zb25ncy5tYXAoc29uZyA9PlxuICAgICAgICAgICAgc29uZy5pZCA9PT0gc29uZ0lkXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgLi4uc29uZyxcbiAgICAgICAgICAgICAgICAgIGlzTGlrZWQ6ICFpc0N1cnJlbnRseUxpa2VkLFxuICAgICAgICAgICAgICAgICAgbGlrZXM6IHNvbmcubGlrZXMgKyAoaXNDdXJyZW50bHlMaWtlZCA/IC0xIDogMSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IHNvbmdcbiAgICAgICAgICApLFxuICAgICAgICB9KSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRvZ2dsaW5nIGxpa2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDcmVhdGUgcGxheWxpc3RcbiAgY29uc3QgY3JlYXRlUGxheWxpc3QgPSBhc3luYyAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBuZXdQbGF5bGlzdDogUGxheWxpc3QgPSB7XG4gICAgICAgIGlkOiBkYXRhLmlkLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgc29uZ0NvdW50OiAwLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgc29uZ3M6IFtdXG4gICAgICB9XG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdQbGF5bGlzdF0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBwbGF5bGlzdFxuICBjb25zdCBkZWxldGVQbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IHByZXYuZmlsdGVyKHBsYXlsaXN0ID0+IHBsYXlsaXN0LmlkICE9PSBwbGF5bGlzdElkKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVuYW1lIHBsYXlsaXN0XG4gIGNvbnN0IHJlbmFtZVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC51cGRhdGUoeyBuYW1lOiBuZXdOYW1lIH0pXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiBcbiAgICAgICAgICBwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCBcbiAgICAgICAgICAgID8geyAuLi5wbGF5bGlzdCwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICA6IHBsYXlsaXN0XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuYW1pbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHNvbmcgdG8gcGxheWxpc3RcbiAgY29uc3QgYWRkU29uZ1RvUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBzb25nOiBTb25nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgcGxheWxpc3RfaWQ6IHBhcnNlSW50KHBsYXlsaXN0SWQpLFxuICAgICAgICAgIHNvbmdfaWQ6IHNvbmcuZmlsZV9pZFxuICAgICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCBzb25nRXhpc3RzID0gcGxheWxpc3Quc29uZ3Muc29tZShzID0+IHMuaWQgPT09IHNvbmcuaWQpXG4gICAgICAgICAgICBpZiAoIXNvbmdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gWy4uLnBsYXlsaXN0LnNvbmdzLCBzb25nXVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGltYWdlOiB1cGRhdGVkU29uZ3NbMF0/LmltYWdlIHx8IHBsYXlsaXN0LmltYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXlsaXN0XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzb25nIHRvIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBzb25nIGZyb20gcGxheWxpc3RcbiAgY29uc3QgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgncGxheWxpc3RfaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCdzb25nX2lkJywgcGFyc2VJbnQoc29uZ0lkKSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICAgIGlmIChwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gcGxheWxpc3Quc29uZ3MuZmlsdGVyKHNvbmcgPT4gc29uZy5pZCAhPT0gc29uZ0lkKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgIHNvbmdDb3VudDogdXBkYXRlZFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgaW1hZ2U6IHVwZGF0ZWRTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxheWxpc3RcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc29uZyBmcm9tIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBsYXN0IHNvbmcgaW4gdXNlciBwcm9maWxlXG4gIGNvbnN0IHVwZGF0ZUxhc3RTb25nID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnVwZGF0ZSh7IGxhc3Rfc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgbGFzdCBzb25nOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29yZCBsaXN0ZW5pbmcgaGlzdG9yeSB3aXRoIHByb3BlciB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHJlY29yZExpc3RlbmluZ0hpc3RvcnkgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSByZXR1cm5cblxuICAgIC8vIElmIHRoZXJlJ3MgYSBwcmV2aW91cyBzb25nIHBsYXlpbmcsIHJlY29yZCBpdHMgbGlzdGVuaW5nIHRpbWVcbiAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSkge1xuICAgICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCk7XG5cbiAgICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygndXBzZXJ0X2hpc3RvcnlfbWludXRlcycsIHtcbiAgICAgICAgICAgIHVzZXJfdXVpZDogdXNlcklkLFxuICAgICAgICAgICAgc29uZ19maWxlX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBIaXN0b3J5IHVwZGF0ZWQ6ICske21pbnV0ZXN9IG1pbnMgZm9yIHNvbmcgJHtjdXJyZW50U29uZ1JlZi5jdXJyZW50fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWNvcmRpbmcgcHJldmlvdXMgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBuZXcgc29uZyBhcyBjdXJyZW50XG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IHNvbmdJZFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG5ldyBEYXRlKCkpXG4gICAgXG4gICAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgICBhd2FpdCB1cGRhdGVMYXN0U29uZyhzb25nSWQpXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHN1cGFiYXNlLnJwYygnaW5jcmVtZW50X3Nvbmdfdmlld3MnLCB7IHNvbmdfZmlsZV9pZDogcGFyc2VJbnQoc29uZ0lkKSB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5jcmVtZW50aW5nIHNvbmcgdmlld3M6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0b3AgY3VycmVudCBzb25nIHRyYWNraW5nICh3aGVuIHBsYXllciBpcyBjbG9zZWQpXG4gIGNvbnN0IHN0b3BDdXJyZW50U29uZ1RyYWNraW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgJiYgY3VycmVudFNvbmdTdGFydFRpbWUgJiYgdXNlcklkKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKVxuICAgICAgY29uc3QgbWludXRlc0xpc3RlbmVkID0gKGVuZFRpbWUuZ2V0VGltZSgpIC0gY3VycmVudFNvbmdTdGFydFRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApXG4gICAgICBcbiAgICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygndXBzZXJ0X2hpc3RvcnlfbWludXRlcycsIHtcbiAgICAgICAgICAgIHVzZXJfdXVpZDogdXNlcklkLFxuICAgICAgICAgICAgc29uZ19maWxlX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgc29uZyBoaXN0b3J5IG9uIHN0b3A6JywgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+bkSBIaXN0b3J5IHVwZGF0ZWQgb24gc3RvcDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlY29yZGluZyBmaW5hbCBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IG51bGxcbiAgICBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZShudWxsKVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBkYXRhIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW2ZldGNoU29uZ3MoKSwgZmV0Y2hQbGF5bGlzdHMoKSwgZmV0Y2hSZWNlbnRseVBsYXllZCgpXSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9hZERhdGEoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBkYXRhIHdoZW4gbm8gdXNlclxuICAgICAgc29uZ3NDYWNoZS5jdXJyZW50ID0gbnVsbFxuICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSBudWxsXG4gICAgICBzZXRTb25ncyhbXSlcbiAgICAgIHNldFBlcnNvbmFsaXplZFNvbmdzKFtdKVxuICAgICAgc2V0VHJlbmRpbmdTb25ncyhbXSlcbiAgICAgIHNldFBsYXlsaXN0cyhbXSlcbiAgICAgIHNldExpa2VkU29uZ3MobmV3IFNldCgpKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgIHNldExhc3RQbGF5ZWRTb25nKG51bGwpXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW2dldFVzZXJJZCgpXSkgLy8gQWRkIGRlcGVuZGVuY3kgdG8gcmUtcnVuIHdoZW4gdXNlciBjaGFuZ2VzXG5cbiAgLy8gQWxzbyBsaXN0ZW4gZm9yIHN0b3JhZ2UgY2hhbmdlcyAod2hlbiB1c2VyIGxvZ3MgaW4vb3V0IGluIGFub3RoZXIgdGFiKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVN0b3JhZ2VDaGFuZ2UgPSAoZTogU3RvcmFnZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09ICd1c2VyX2lkJykge1xuICAgICAgICBjb25zdCB1c2VySWQgPSBlLm5ld1ZhbHVlXG4gICAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW2ZldGNoU29uZ3MoKSwgZmV0Y2hQbGF5bGlzdHMoKSwgZmV0Y2hSZWNlbnRseVBsYXllZCgpXSlcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHNldExvYWRpbmcoZmFsc2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVzZXIgbG9nZ2VkIG91dFxuICAgICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IG51bGxcbiAgICAgICAgICBsaWtlZFNvbmdzQ2FjaGUuY3VycmVudCA9IG51bGxcbiAgICAgICAgICBzZXRTb25ncyhbXSlcbiAgICAgICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhbXSlcbiAgICAgICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgICAgIHNldFBsYXlsaXN0cyhbXSlcbiAgICAgICAgICBzZXRMaWtlZFNvbmdzKG5ldyBTZXQoKSlcbiAgICAgICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgICAgIHNldExhc3RQbGF5ZWRTb25nKG51bGwpXG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgaGFuZGxlU3RvcmFnZUNoYW5nZSlcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBoYW5kbGVTdG9yYWdlQ2hhbmdlKVxuICB9LCBbXSlcblxuICByZXR1cm4ge1xuICAgIHNvbmdzLCAvLyBhbGwgc29uZ3NcbiAgICBwZXJzb25hbGl6ZWRTb25ncywgLy8gc21hcnQgc29ydGVkLCBmaWx0ZXJlZCwgYW5kIGhpc3RvcnktZXhjbHVkZWQgbGlzdFxuICAgIHRyZW5kaW5nU29uZ3MsIC8vIHRvcCAxNSB0cmVuZGluZyBieSB2aWV3cytsaWtlc1xuICAgIHBsYXlsaXN0cyxcbiAgICBsaWtlZFNvbmdzOiBzb25ncy5maWx0ZXIoc29uZyA9PiBzb25nLmlzTGlrZWQpLFxuICAgIHJlY2VudGx5UGxheWVkU29uZ3MsXG4gICAgbGFzdFBsYXllZFNvbmcsXG4gICAgbG9hZGluZyxcbiAgICB0b2dnbGVMaWtlLFxuICAgIGNyZWF0ZVBsYXlsaXN0LFxuICAgIGRlbGV0ZVBsYXlsaXN0LFxuICAgIHJlbmFtZVBsYXlsaXN0LFxuICAgIGFkZFNvbmdUb1BsYXlsaXN0LFxuICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3QsXG4gICAgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSxcbiAgICBzdG9wQ3VycmVudFNvbmdUcmFja2luZyxcbiAgICByZWZyZXNoRGF0YTogKCkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgICBQcm9taXNlLmFsbChbZmV0Y2hTb25ncygpLCBmZXRjaFBsYXlsaXN0cygpLCBmZXRjaFJlY2VudGx5UGxheWVkKCldKVxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHNldExvYWRpbmcoZmFsc2UpKVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGVyc29uYWxpemVkU29uZ3MsXG4gICAgZ2V0U21hcnRQZXJzb25hbGl6ZWRTb25nc1xuICB9XG59Il0sIm5hbWVzIjpbInN1cGFiYXNlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTdXBhYmFzZURhdGEiLCJzb25nc0NhY2hlIiwibGlrZWRTb25nc0NhY2hlIiwic29uZ3MiLCJzZXRTb25ncyIsInBlcnNvbmFsaXplZFNvbmdzIiwic2V0UGVyc29uYWxpemVkU29uZ3MiLCJ0cmVuZGluZ1NvbmdzIiwic2V0VHJlbmRpbmdTb25ncyIsInBsYXlsaXN0cyIsInNldFBsYXlsaXN0cyIsImxpa2VkU29uZ3MiLCJzZXRMaWtlZFNvbmdzIiwiU2V0IiwibGFzdFBsYXllZFNvbmciLCJzZXRMYXN0UGxheWVkU29uZyIsInJlY2VudGx5UGxheWVkU29uZ3MiLCJzZXRSZWNlbnRseVBsYXllZFNvbmdzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50U29uZ1N0YXJ0VGltZSIsInNldEN1cnJlbnRTb25nU3RhcnRUaW1lIiwiY3VycmVudFNvbmdSZWYiLCJnZXRVc2VySWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZ2V0U21hcnRQZXJzb25hbGl6ZWRTb25ncyIsInVzZXJJZCIsImxpc3RlbmVkU29uZ3NJbkJhdGNoIiwiZXhjbHVkZVNvbmdzIiwiY29uc29sZSIsImxvZyIsIm1hcCIsInMiLCJuYW1lIiwibGVuZ3RoIiwicHJlZmVycmVkVGFncyIsInByZWZlcnJlZEFydGlzdHMiLCJmb3JFYWNoIiwic29uZyIsInRhZ3MiLCJ0YWciLCJhZGQiLCJ0b0xvd2VyQ2FzZSIsImFydGlzdCIsIkFycmF5IiwiZnJvbSIsInNvbmdzRGF0YSIsImN1cnJlbnQiLCJkYXRhIiwiZXJyb3IiLCJzZWxlY3QiLCJ3YXJuIiwidXNlckxpa2VkU29uZ3MiLCJsaWtlZERhdGEiLCJlcSIsIml0ZW0iLCJzb25nX2lkIiwibGFuZ3VhZ2VGaWx0ZXIiLCJsYW5ndWFnZSIsImF2YWlsYWJsZVNvbmdzIiwiZmlsdGVyIiwiaGFzIiwiZmlsZV9pZCIsInRvU3RyaW5nIiwic2NvcmVkU29uZ3MiLCJzY29yZSIsInNvbmdUYWdzIiwibWF0Y2hpbmdUYWdzIiwibGlzdGVuZWRMYW5ndWFnZXMiLCJpbmNsdWRlcyIsIk1hdGgiLCJsaWtlcyIsInZpZXdzIiwicmFuZG9tIiwiY29udmVydERhdGFiYXNlU29uZyIsInJlY29tbWVuZGF0aW9ucyIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwiZW50cnkiLCJkYlNvbmciLCJpc0xpa2VkIiwiaW1nX2lkIiwiaWQiLCJpbWFnZSIsImZldGNoU29uZ3MiLCJvcmRlciIsImFzY2VuZGluZyIsImhpc3RvcnlEYXRhIiwiaGlzdG9yeUVycm9yIiwidG9wSGlzdG9yeSIsImgiLCJ0YWdDb3VudCIsImFydGlzdENvdW50Iiwic29uZ09iaiIsImlzQXJyYXkiLCJ0IiwiY29tbW9uVGFncyIsIk9iamVjdCIsImVudHJpZXMiLCJjb21tb25BcnRpc3RzIiwiaGlzdG9yeVNvbmdJZHMiLCJjb252ZXJ0ZWRTb25ncyIsImZpbHRlcmVkU29uZ3MiLCJwZXJzb25hbGl6ZWRTb3J0ZWQiLCJ0cmVuZGluZyIsInVzZXJEYXRhIiwic2luZ2xlIiwibGFzdF9zb25nX2ZpbGVfaWQiLCJsYXN0U29uZyIsImZpbmQiLCJnZXRQZXJzb25hbGl6ZWRTb25ncyIsImN1cnJlbnRTb25nIiwibGlzdGVuZWRTb25ncyIsInNpemUiLCJoaXN0b3J5TWFwIiwiTWFwIiwic2V0IiwibWludXRlc19saXN0ZW5lZCIsImxpc3RlbmVkTWludXRlcyIsImdldCIsIm1pbiIsImZldGNoUmVjZW50bHlQbGF5ZWQiLCJsaW1pdCIsInJlY2VudFNvbmdzIiwiZmV0Y2hQbGF5bGlzdHMiLCJwbGF5bGlzdHNEYXRhIiwiY29udmVydGVkUGxheWxpc3RzIiwicGxheWxpc3QiLCJwbGF5bGlzdFNvbmdzIiwicGxheWxpc3Rfc29uZ3MiLCJwcyIsInNvbmdDb3VudCIsInRvZ2dsZUxpa2UiLCJzb25nSWQiLCJzb25nRmlsZUlkIiwicGFyc2VJbnQiLCJpc0N1cnJlbnRseUxpa2VkIiwiZGVsZXRlIiwicnBjIiwic29uZ19maWxlX2lkIiwicHJldiIsIm5ld1NldCIsImluc2VydCIsInVzZXJfaWQiLCJwcmV2U29uZ3MiLCJwcmV2UGxheWxpc3RzIiwiY3JlYXRlUGxheWxpc3QiLCJuZXdQbGF5bGlzdCIsImRlbGV0ZVBsYXlsaXN0IiwicGxheWxpc3RJZCIsInJlbmFtZVBsYXlsaXN0IiwibmV3TmFtZSIsInVwZGF0ZSIsImFkZFNvbmdUb1BsYXlsaXN0IiwicGxheWxpc3RfaWQiLCJzb25nRXhpc3RzIiwic29tZSIsInVwZGF0ZWRTb25ncyIsInJlbW92ZVNvbmdGcm9tUGxheWxpc3QiLCJ1cGRhdGVMYXN0U29uZyIsInJlY29yZExpc3RlbmluZ0hpc3RvcnkiLCJlbmRUaW1lIiwiRGF0ZSIsIm1pbnV0ZXNMaXN0ZW5lZCIsImdldFRpbWUiLCJtaW51dGVzIiwicm91bmQiLCJ1c2VyX3V1aWQiLCJzdG9wQ3VycmVudFNvbmdUcmFja2luZyIsImxvYWREYXRhIiwiUHJvbWlzZSIsImFsbCIsImhhbmRsZVN0b3JhZ2VDaGFuZ2UiLCJlIiwia2V5IiwibmV3VmFsdWUiLCJmaW5hbGx5Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWZyZXNoRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});